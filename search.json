[{"title":"equation test","url":"/2022/02/18/equation_test/","content":"\nYour browser does not support the video tag.\nThis is my website, click the button ButterflyThis is my website, click the button Butterfly\n默认 提示块标籤\n\ndefault 提示块标籤\n\nprimary 提示块标籤\n\nsuccess 提示块标籤\n\ninfo 提示块标籤\n\nwarning 提示块标籤\n\ndanger 提示块标籤\n\n\n            纯文本测试\n            \n\n            支持简单的 markdown 语法\n            \n\n            支持自定义颜色\n            \n\n            绿色\n            \n\n            黄色\n            \n\n            青色\n            \n\n            蓝色\n            ","tags":["acwing"]},{"title":"pyTorch获取中间层输出的几种方法","url":"/2021/07/18/python/Pytorch%E8%8E%B7%E5%8F%96%E4%B8%AD%E9%97%B4%E5%B1%82%E8%BE%93%E5%87%BA%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/","content":"总结了3种输出网络中间层的方法\n\n方法1import torchimport torch.nn as nnmodel = nn.Sequential(            nn.Conv2d(3, 9, 1, 1, 0, bias=False),            nn.BatchNorm2d(9),            nn.ReLU(inplace=True),            nn.AdaptiveAvgPool2d((1, 1)),        )# 假如想要获得ReLu的输出x = torch.rand([2, 3, 224, 224])for i in range(len(model)):    x = model[i](x)    if i == 2:        ReLu_out = xprint(&#x27;ReLu_out.shape：\\n\\t&#x27;,ReLu_out.shape)print(&#x27;x.shape：\\n\\t&#x27;,x.shape)\n方法2from collections import OrderedDict import torchfrom torch import nn  class IntermediateLayerGetter(nn.ModuleDict):    &quot;&quot;&quot;    Module wrapper that returns intermediate layers from a model    It has a strong assumption that the modules have been registered    into the model in the same order as they are used.    This means that one should **not** reuse the same nn.Module    twice in the forward if you want this to work.    Additionally, it is only able to query submodules that are directly    assigned to the model. So if `model` is passed, `model.feature1` can    be returned, but not `model.feature1.layer2`.    Arguments:        model (nn.Module): model on which we will extract the features        return_layers (Dict[name, new_name]): a dict containing the names            of the modules for which the activations will be returned as            the key of the dict, and the value of the dict is the name            of the returned activation (which the user can specify).    &quot;&quot;&quot;        def __init__(self, model, return_layers):        if not set(return_layers).issubset([name for name, _ in model.named_children()]):            raise ValueError(&quot;return_layers are not present in model&quot;)         orig_return_layers = return_layers        return_layers = &#123;k: v for k, v in return_layers.items()&#125;        layers = OrderedDict()        for name, module in model.named_children():            layers[name] = module            if name in return_layers:                del return_layers[name]            if not return_layers:                break         super(IntermediateLayerGetter, self).__init__(layers)        self.return_layers = orig_return_layers     def forward(self, x):        out = OrderedDict()        for name, module in self.named_children():            x = module(x)            if name in self.return_layers:                out_name = self.return_layers[name]                out[out_name] = x        return out# examplem = torchvision.models.resnet18(pretrained=True)# extract layer1 and layer3, giving as names `feat1` and feat2`new_m = torchvision.models._utils.IntermediateLayerGetter(m,&#123;&#x27;layer1&#x27;: &#x27;feat1&#x27;, &#x27;layer3&#x27;: &#x27;feat2&#x27;&#125;)out = new_m(torch.rand(1, 3, 224, 224))print([(k, v.shape) for k, v in out.items()])# [(&#x27;feat1&#x27;, torch.Size([1, 64, 56, 56])), (&#x27;feat2&#x27;, torch.Size([1, 256, 14, 14]))]\n方法3：hookclass TestForHook(nn.Module):    def __init__(self):        super().__init__()        self.linear_1 = nn.Linear(in_features=2, out_features=2)        self.linear_2 = nn.Linear(in_features=2, out_features=1)        self.relu = nn.ReLU()        self.relu6 = nn.ReLU6()        self.initialize()    def forward(self, x):        linear_1 = self.linear_1(x)        linear_2 = self.linear_2(linear_1)        relu = self.relu(linear_2)        relu_6 = self.relu6(relu)        layers_in = (x, linear_1, linear_2)        layers_out = (linear_1, linear_2, relu)        return relu_6, layers_in, layers_outfeatures_in_hook = []features_out_hook = []def hook(module, fea_in, fea_out):    features_in_hook.append(fea_in)    features_out_hook.append(fea_out)    return Nonenet = TestForHook()&quot;&quot;&quot;# 第一种写法，按照类型勾，但如果有重复类型的layer比较复杂net_chilren = net.children()for child in net_chilren:    if not isinstance(child, nn.ReLU6):        child.register_forward_hook(hook=hook)&quot;&quot;&quot;&quot;&quot;&quot;推荐下面我改的这种写法，因为我自己的网络中，在Sequential中有很多层，这种方式可以直接先print(net)一下，找出自己所需要那个layer的名称，按名称勾出来&quot;&quot;&quot;layer_name = &#x27;relu_6&#x27;for (name, module) in net.named_modules():    if name == layer_name:        module.register_forward_hook(hook=hook)print(features_in_hook)  # 勾的是指定层的输入print(features_out_hook)  # 勾的是指定层的输出\n","categories":["教程"],"tags":["pyTorch"]},{"title":"Neovim + Ubuntu快速搭建教程","url":"/2021/04/30/ubuntu/nvim_linux/","content":"Neovim + Ubuntu快速搭建教程先说下目的吧，因为自己经常需要在GPU服务器上跑DL模型，大多数时候是通过本地debug之后的代码上传到服务器来跑。这样最大的问题就是效率太低，每次出错都要把代码拉下来修改。其次呢，因为是通过终端来操作大部分使用的是vim编辑器。说实话，写了这么多年的代码了vim用的是相当的不熟练。所以想学一学vim并且想要找到一个好的插件，能够满足我的一下需求：\n\n[x] 方便文件的操作（增删改查）\n[x] 支持python自动补全\n[ ] 可以debug\n[x] 以上操作均是通过终端实现\n\n正好在b站看到大佬TheCW出得Neovim教程发现vim效率确实高，于是花了几天自己动手搭建了一次。中间多多少少遇到了一点坑，总结一下为了以后配置更快点吧。\n\nInstallation\n[ ] Ubuntu 18.04 LST\n[ ] Neovim 0.5.0+\n\n安装Neovim这里遇到了一点坑，就是一开始使用命令sudo apt-get install neovim无奈可能是apt版本太低，导致安装的Neovim版本为0.2.x。GooGle到一篇文章推荐使用ppa安装，命令如下：sudo add-apt-repository ppa:neovim-ppa/unstablesudo apt updatesudo apt install -y neovim第一行指定为unstable可下载最新的版本.\n安装Nodejs这里是踩的第二个坑，由于需要配置许多插件，其中coc.nvim在启动nvim时老弹出错误，搞了半天才发现是Nodejs版本太低。需要12.12.x以上，但是我这台服务器已经装了6.x的版本，一开始在配环境变量上耽误了许多时间，但还是没搞定。最后采用了另外一种方法，通过nvm安装。这里介绍一下，nvm是针对nodejs的专门软件，可以很方便的安装卸载各个版本。这里的命令如下：wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | bash其中 v0.38.0为nvm的版本，可通过这里查看Lastest nvm version\n安装好nvm之后可安装nodejs了，这里安装的版本为v14.17.3nvm install &lt;version-number&gt;nvm use &lt;version-number&gt;\n下载vim-plug插件github 自己搜吧\n设置nvim的配置文件+插件与vim不同的是，nvim的配置文件在～/.config/nvim/init.vim，vim在～/.vim/.vimrc首先，进入.config文件夹并clone我放在GitHub上的配置文件cd ~/.config/git clone https://github.com/wudi1183456665/nvim.gitcd nvimmkdir plugged tmp\n启动nvim及安装插件首次启动时可通过终端输入nvim启动，强迫症的我习惯了之前的vim启动，这里可以修改zsh的启动文件打开vim ~/.zshrc\n添加alias vim=’nvim’\n插件的安装也很容易，主要就是网速太慢进入nvim，输入:PlugInstall 应该会自动安装，安装完成后就可以愉快的使用了。\n","categories":["干货"],"tags":["ubuntu","neovim"]},{"title":"English Interview","url":"/2021/04/30/%E5%8D%9A%E5%A3%AB%E7%94%B3%E8%AF%B7/%E8%8B%B1%E8%AF%AD%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%97%AE%E9%A2%98/","content":"\n  fdce470aa48e507ad61ad4892d2912452abbc4c68792d922f0f76e59c9d0840686dceffd1dabec383d0d95fb7fe6dcd72d34becd6212faf66f2b7d055e48652e115dcfc261fd144f4b7a9ff38c681c97efa839fcfcfa89f4699c83f46bd406a1a309eabbc1cdfd65cf2ad1e3ebc7764f7bd2e7b79af4b9982f5dfa46ccbc4110db1421f53a95d06be71e626c07a2328effccb331a58283ee0d9a98bc8d9f524b19334178ac17fcd057e99a0e95d8f7a7554050bbaa156e649624391ae0045c42f63bc18ad500a91980c6267634bdea12788c55f05f3cfed24ea9f1546b4c8b1ab1b78d27c283be017c6317bad262b87bd6658a7c1d2b61e5c6a740ffc502df99b171c43cfdb39baa7c9131fe2e07093c9becc5170bb6033f16dad318714459867a642e6f73652d792d8cb8f1531efb2e9dfd9fb5e5cf70ab3c362139aa4361f0089ec208fe395142d91db43e632d104211c0b053586799e09554fd04d52d34eee30c0ebc7c8a43f34005aebe92d073ffad46a4be029cb43d5908f54b818ec3791bad8649407c61f3d27353b28884af2a4b356995ceaf11358f258a79cf285689199fa371c1c16faa7bdf92a8f6bc8ef560be1d1e46d2cea8293b171bc082361da7047db1eb79f7d43e0cc4ac5ddb0b1655446a78a3881eb15e669498314eadc72ed62e9107b7e57066eea1e27d0c5e8256a930b0142466ec9646e49bcbd1755bbe9530e22b1e604b186f0cab28683ee0aa0df0ee2a704dd2704384b58f39508b441fe6e5866a196605e4b9f8ca86668da1e481c209d3c05a3848eb3113e9403ecbaf8d9dcf354c3de2024f4f2bcd1c68ad05098c80f84819968d922618030ddbef2b87a73c539147e6ef75160302e6d22f29948907d37d628f153dd6b307973b825aa0a7be918ad3df7ac59a304b72d8d47c97288b244462a1abdd1e1f218fd41e4ba9c3213ca2477bf37db6db236735122632010cd860d44e17bba6721cedb7f1bd1c2f3f68627e3448c58c253ac1b4c32ae10f03f5a94643f30830b3979bb8b09a0e7748200181ce68787456bacd09bb07bc6c4a5fa64d26ace43a2cc8be671f69fbeba1d0443e2d85faf2ae22e65297e72795165d9fcc3f58e81755effacebbbf1580d255810331c44a272f0bc7334b7ff50c8215d86747cd1121ed778b4606e7874c5cc906db5db9149552ae521e98239c812af99e709fcf483bf60385110b8b3b91ab86638cdd1e23a92a14db0fb546494de0b042ac616f7f571212c6deeaab6487b62a154ac886f716ee58a041cd0e2e2403f3fdca8312fdf0df859f7cf8929f16e0fa3a91cf9594ca7e2dc61b284dd7e096ea5cfe8cd7423cdad7e863add6fae98fbea620715c59af5744ada460ec2564ebe23319720423a881a592e83e8a3d9d2295d4417221cf28c2cdc7b5b4dad15cc2e150910bf4e0096eacfa180e8d3433078fbb9b59cf15bd7aaeedcc23e665c7f7c4b14b21190e86deec95fbb406939124946374e9c8800087f080adb4f990be6d72a0859dee3e725006642698012756c66f44235bd9d1414e51c6fdfd65cac57a72f0031784428e31e5841ea6d7ef799a5f4d64065af22a2e8d9bec5051f66ca7dd5da5740edf149f4eab32c696c86bad87a5f426ce00b0909366e41e8adc0591325dff119b7b034a11c3b261ff24168f391f76f4a0071ae097094f760d4d6b969919830fd04efeef5a6487a56895d56429120d0aef166983dbaaff16da37854b7693e8bbf4cafe53016eeb051a011782054ba2872edd3ab42b40b2ff72eb264f4bffffe9297ec0213de491616582e869694e429c8e47875f02a3c877e3236db1fa19585c22b46ada05e8607cc35c679b624a0233d4f73bef6435e74a0a5d5e46a36f0e3b1517f1d7d8de66e2ef2d0b7dc8ef158216e68adbf12a616550ffcadda2ae16b4afa7da8c511b58a777ebccc37bafbdb442d6e3af446df5148bc731f7e13caf77d2e3800f49c5b40df78a2f1892416004067f1f7253321aef0159575cd02b1bc5526b2f2eabc7edb4f7545aee057beb8d5c0669adf1ac63c259c47b85313b870fdb60e784aaab49f1b9ea1045030033484e1acf0243813ff9008be83336b2fb13400814d513563c525c2b8644ba9520c85531a829128f74aba603050a9f136b9f2db0e16a9cd79e9c6df93893870eac66034af734d7cf2208c0a296da28744dd13715ce8d78f8563f49b68dfb488eb5eab7984ef52c0a24c60796557ca69dc6c65749305f24f8ec2000e86f819b2afa0534dc4a7e0c50450ba49903eb7b32ab25d1cc853fd75f97563fde2750ffe5c6140e1165c8e0d48465c7ba4dc9fa0d0463645ea7d38d0180a0e2aef48b2995d3d0b340a7e0d09bf49aea132b338a6ed71f31aa0202289a1e06cea5ee0169fdec85f17813d33ee565aca6b96211c7f75860f325a7795a7314310af99c6f7a8825d869fe9c95d256700509a38cd46b55f5af50fe3a307c8e19de0f47f01f68a203f7403a8c87f2752d9f1f30c766a5c760bcb6d07bee81167ab6a3099ec168ff3b4372f1f54894b2a00131b88197302022b52762e5463198a32ed388975f8fdda7a12d2571806a4b7319eccf5abc0f540ae01eece9fd26181380d3f7581d1d2e739b5b8f53f572f825020de786dd22f4a0b867f8ef3bbe54724d059e330eca99d08668ea2d51449524f6907f41dbdc1b444341cc2b3ac81b1ef3149bfcc2babfe200ec8c5520319b270216bf1efd48cd6f924da17c90c97fee0b289710b0658787b65aa78bfd3373f39f8b72169bbd4291d013c7867ac5f5268fe04036a5fbde68f2359e19419c369ac9b655f01ef5f57ae02004b45d80d548ee70d32bd2cba24c4f3fa9732a598ab6fc4c66810ee8a5c4b8a9db296559f783f1ee6d19270d031a8f61a7a22a063014f9f82b0ddf7981adbafb64227ff41433e2a6c4e1d824e2f08f7d755bdc10cf0b033523bc08667661e50dc8ac79ea63d97c21682e498555891ee304d02948bd3839ab5dbbabeea25c71bfea984e6327c3f0839b74ae10f8a4adca740faf2d749510430638646c146697da89719ac7005b40e5251fdc77660485671482518e068066b1ae66548a597e02f4f8bb6370aaac26837c4670476a48fce0b74dcf32d8113abd06eac149be9149fd421a58362181b4f9b6486ad69d1a78bc24867281c260b6a55789704e1749153116e6dbae0a7f22922752649bce5a101d70e5d0b1171844184fee527e420bce5915b27677e8b2780cb852cabd4588f2470eeea12f701050c738dffe974586aeb3c89630beacad94571402f076e77fcc0d1be92c3126d3e5e9ea644ba397bb09042761cd218ea2ec48abcc51ba3d4d53a10cc76d774a9f49720e065dc82457fdbe8ec3c0988691426706d259660eabc494b4c6a28c3e41ec8224afd0ad25e69e3d2729d3eb617369c9f96e0c441d4de6648bf88240e0c69aa8f4d3bdf9a473fbf409cd17ebc9835dee95a770526bdc683d67ebc6fa93dcdbe706443055869dca8f211a066bb8ef31266a7cc66dc57d0f69045de11d28c9fc6a57a31a392468dc405485fb55ebb7d434d15194fa05c768dd368d4cbf3d88e2794ca64542cd359c55c3ad109949dc32793751ac124eb334b66c3049a7923cd359fb6d3a3fd0a41b3124e3d434f2763e7c04cbe5a2dea87bf5500b774509526f30a65e03081e4a4684f8f166657aad5b745f4b3b01b84f7123e811f5b5564d793362037aa9df300f77f384f750033352cce3df8f278a714c9c440ad77c3ace3db8331fc3ef837f90867388a16bf4fb9583a32517fffe6a13145b655d3b5010aa9ee633e0ef902ee58b69f1a7973e160025db48a455a7d077d25e916559196e3c356292f70cf17c2a468326e0ac8800535e5ce51b1fa4c07e0683c530b4aedf1033d6d447549023892ead37d0b6fa532dee0b178ac40c7bc73f766c03fd16dac196792323459b5b73129d7b826bbaf219f67df20417370dd7dde072e8b8af1acdbf11134b50a17b32c69627c601f49733dd82d6da7b121db6f267607850dada4c79683f8de8649e54c209dbe2d3125ef211d625d02ea6a5553454f92131cb9359b17333e2591bb72ad09bce32b876913b0b061e98d85e62333ab1e32df954cebb267d11d51a10dff0cc9de91cc4d569d6526b1361abb681d92f6ede1a25c46a000ca8111b98ab2bcd6e947fe4a7622d8dbef93119274ad79769fec0df6736374d3de291f6abfd7c597aa8393545250de65efc29a95d32770fa5c61705a8357eccfc75033aa2cf98a34c8246cb4c0f39c2ff86b2a7b98c9fc45a9a7c8f3c45fd37e8467c29fb6de11f1b99e512bf361e7359b3c2d2f690e0bb701b00d3d9aa083e627a624974fae6a01ce354709c27e051ad5d5e3404b62e1254841b1f70f7fbff580e364908a7580b4f76a10e1f793060a23ace5326135376670d7208fc3bc2858375d66125adca07e547ad1ca2f8b6046a76d1c2a1dcd5d31a402e2efbffafcf11e79f2b34fb8fc6d7cd66b03f08bece054355d2ab6eae7cd19ed763e9c08f087e5d1937e771f76dd59388be4002c7338de18f4afa47f1a4d33aaa65359c0f5b706550db44684feb71915f1c34e143d03794ff1a60072de5690bb87b2618b90b19d79e9be54d16928497b0b44355b0b5f33212f620df0a03714220a0f3e51172349a00dd9a7ff0fbdaea71366ed64a0d7eb5c15d4e45e73a42e955a54c25f2886c54ecb60e122786d8041198761ec20ecad4e97502b450bb14338d827dbdc55b57b00c07a6c58c8ef5e34753b7cb59327f1164137c6b9f22d86a5f21e638a3a8cc8b45652557883c643536ef3d9d19b491ffdd37025b0f96f10305a00bc009234f4403accf3de137c3b01347a232f717fbaae5bc9fc93d67f2d7037eeca7fafe613b7b7b7066b25836c8a866320f18b87d94d3299672876f393f52720ab1348d354fb6f8c6d1e712c2edab59cbf30f18c280593a9331596381fc2bbfbdf6ddb7b16bb3f9a529de22498d3185274cd2bad4e604fb4eede695638ca7cf169500dc594f6044c5fa59ea7fe76a4cbc4ad06accedc3fc5ff1d39176374bd22ad464f2514bae32550bd5a5565754047b5acf42d6e2fdba27608c452b66018ed190bc1cf6fafaa1d3d043a09582265922249226e028e7b1d0de65405926b3fcbf767143f90921f6462c18615ea24f741a9d595aac67bda8cc7ffb9e342f4349a8f1b93e71d35bbf5c06b975b830ff8589bf39748e5104b17564eefcde29fe0805cd32719e40431773fb66fc8271106ad4afbf60fce825de6a1d11402f546925f1008d60b6f9e555b987edba01e4f30e568e4a461e7202b02cdcd6a9eeb4f454b7d6d0168305c4018481ce0e8ed0075fed312a0edd95ec85aa0744b6b454ed067a61acccfdff49bf82218ad2b30df4ea8ccdc6020f1001e08a5e254a5337d1b031ae91bfb24774509ea26f06d2746f3163d3b23cdcc7ed69b2cfb449688de9d68040c50751d0a01a2b6010aca6cf4f5fc843687e250a0fde94be03ef78633a90548ea9c0fe7fcaa4402d2694ba76c58429119f6962c75f8b0182d7522fd1db5d966e443b781eb8727b007c599a4d60a07af05f92dc8b7a36d635169765df58ccb5f7a4ec76cb015f834e0ed5db3991a83f583d632d6f8cb3ff52c998ef7c9b48c9e0422ca906b07d50f3afe36801684b5cfd3b31dad337c0acb88d55ab0afd5e4868d8bf3edb49b1c8d2c93759ae6f872608b00f2a5cc4b5ed0729ca72c6f2f8aea5b31d8c6a8595e98c4bcc8401a733001662fffab00ea260afd56b819ccc5bff75ba20a7e5c7323428ca427cfd9010c97bb3332052198b8f5c0f4e803156743f3ffaeb8d071da31e40cb2211143ced9ad859483bad34d1723930ca2538509455d2e548289b05dd63c2d877e35baf892f5908837cdf69bccc4c4bd2e37a9a4b57d224cd8bb259683ab40333861151d7a277cf71b2aa28d2d843201ab6cfd0168f5f44f54d103c5bca8d446ca40efdb467577469597fec6c989686f1759ae2c046ca3d174528536ae9de80e975eb3b428ed7ff9bbf6ce75d85f5821839115468517f85d572a5bf5941c02b9269ac7fdf8e87f582898bd85ff097cd475ae32b88c85932b5447eac8340098ce266bc3dbd9912382dcc158e2dc1a3433ae95df3ca94432d608067f8a7dc6de153270342ba2e467bbd663577a160e0f3b5101442d9fae394a6517c2b326e381e82378af8371cdaa365b31ada5984e857fa5d12babb35fbe184b27d79e62dd568b76896a0c26f0ad7319bf9636406b10d00846ab23dcc8cda92c50dd630ac011b7c71e766ae3f82738b0239715cb2e8b0714237b529bfcbb5aab66720a6d2ea3d37eb9d1b6f3ed619eebc1f2fc171087de3ae3e629ece814118bed3e648aec9cae898f95ac4828542bdd1e072b648482b6255e655333947515548104cd3df0ff5505bc74d86ff26092c7bafd2a3be1fc4824cfe4e2d903c80010af37c95dec06ba4255180fdc937262a3b8d5bbfa4d71e1b8c56da8cfa5dd024b70f086f7a002c502ebd9e03aa75a7fda24356cc123fe744c717a3dd657f8a3561b916ae90b2b103826b14655ffeff0911cc01c131dc88cc5f6e16a7357096736526002246d9566d704ff127a683037245cb03aa26c6758d60b65914fc725e18e0679b6fac8c42157c291d4b1c57580a9e3afa9184e33fa9c3aa195fdd5acfc72b2cd36da62938f3f6598069a8ea1f4941e6757b5021393b1c52e2d4f36b35794ae412b960f6fc300b0e5ccf9c55abb08fa9b6897e65bdb391b4a98389e58f6cbe79410e196c5940e61f9027deef77e0aeebbf28775656b0d235953dab96909c32eeadc3ec61d499ba6aeb3500cef23ab63830f67ec1c07ca5310cffab39ddc9d398ea45f0d50c58f1fd260342e1521ba3184d7e0a8681ade789f4233e80e1d197be272e382ca5daf9f84e8fb1b1b5581a3c326ebdaa1b5df2bd798cda6dea386033de9f1024e910243da9c1be2fab7baebd1de907a8b8fd14fda621dc57f14e278094f577dab7e1e2fc3295088f7396e7665052cae8cb233f47e7b389feda234d44a8c13cc60a30f5541b2d08e173104dc97e44869323bfdc8190e30d94a2fcdf249f3ec78e8ce1b683908df37c6e5c9c47a6bd02037fd201a8577d4f19e5b3488e82fbaa090e9f7e992ce56b02dccbb4ee887fe3504617d125b0f80c66891dd8652097928cd1f66a44f54ff803b7b6d44da01bd5c5298c3b8bc6ead2235e7b2f72b6e4d335a4c8e347c40def417ba64257a879d6a4617c94e22ce9c4f21a95df398b7bdcb7e3c83fe7c0a8f271bbaa2c2606d92a6f3bf7991569a50ce614ed73a86dc7f362308899e325aab00d06a975066f0506a3b30046981d0941f65e17e05c3283d0b5ed6633a705ed90a221cbc892fc5572288183ea006bc83c48fdbe31f23acd3aa55207e7d583f74349cb6609e7849802443b4834fa3fee278020dc40f56c819a21696427905de90d8bde73f31933caf66871aabc6e375aba4e496a7d216d3e6b449f68f2c5c07ce5ebd2c61eef95e7e05d15a8317a831b12666de016eab708c89023223c7f5bb456b1afa758b820e26975a6c16de1fe1eff5ad4786ccdd808601ffa23f59499c8bca5bfd14427c36bd365001134dede46bade845cbc47886e14aebe2fd18d5586a53447c3f205ac4826dc8dba74f5ea47d68675bd31d6d9e3f53663a7aecc26830e91550f4d13295e03e339945bb8482f5d711f17d627f820e7885d909d87bd0a8469373c9b143ed1d6d6f3d9ce392fb2616766c704d730df0635d21670e4dadffdf71105bc0862e24edfd61a21d3c7db4af17feb4f3cdbaae80f10819974cd8d88b3e7ab7426b9d3e0b406c5164386319b992eb176cd92985dbc36bb9410283861bb6a8e0d19112c12caf6a022437bf0cb1535c5ddfe2dc568bc4e62848476a2ac58f539853687be953afbe386cdd05056e2c03fd24734329dcc770b267a533e6c89e268586bcf3d566085e8ff52cfdd55381b7b2c3ef912f505f1f3bc22f77bea575cce54b4a448d289fc5dc41523001aee5670fc33d60dae1d2c3091c55dcd53b73d09e55ec92da41821c2b489b210517b9a7c5e25896def7935bb8b9829b6ef69a2c089406d9dd37ddb81cd1132c174c75158efb2942080c258da1f8fa51d0b5ab5d65321f6313ce10bef5cdafbf8f11b3e665dd24fe6bd5237a9bc0b192008211fe0d84b39ef6334d239bca8d9aa542a64d45ee2ca621baa21550b748e6df9cd5d774038ad340b842ea350ff59b84e6064ea3ed243d20efc70c34dddd863ec86cae1a20b1aefbcd114e0ca4cf463c23703e20d29a040c6027296bf86d66b663f8056ccf729b60f9ba0c07b59d792cc835af2780b62e57aa6c68cb66647f917b00480cd319ef5724ebc2d520398d2100f6821a801321fedf7f5f8a77026ee08d67c1a9f0b0604e0df82b5c0a7d8831dd59e2a708c61a6dcd61cccf25d909f652b14165723f54afceeabb843bd274c479c29752ebcc7d8e169ea64cc8276f17d5d0781d9312d36c40351fb01488c90b3252033be204a88fcb9da8588a45e6fa3143977b620dc5809425603e8536ef99fa3363fa1ff71c4a9d44fd49a8740ca5d1276033a3c0138e36bb1b1e3da927ad76715b36b77ae531de979854f27b1aa75eb3c57f0f7588a78efd7ffba0ca32691f1bd14a8214e6991b140829627cfeb48e4bca471514c3ad197058dc0e82efefd3f19602f11abfa14694c36681a70443d12a482f5312a3f11ebce4d91a8f9cea23e727f2c7dac9cb9fd937e9c4a529de0eac81de3f361eb4884d45df578010f8c905e1f375c80db37e11d6bf084e53ec4e10c7d6ec257933b3910b1a370fef6ede3a692daa1033171e485980227e24a0233d4bfc297d214f63e10b98c1ad8296944a6119f1c19e9b325e33ba33bbf617869720c9309f9d72661a00677c043877ebb90514cc45dbd9d874174ae4cc4b8c4b6d20f72d712c4da6f70fff7073b8742a25866964a1a10388ca8039697019c78b1f0d508dfb2584be729562e449ad3f0640b3d10631e7214196dd9d1164d7cbae378076c670f86e78612bb71412971311f48c73f376ab7da9b8b6e6d17590be6ab3161288e889252f75c9d658ed40803f96228b6213c6ac9e9b922e92069974dbcf3925da8d7098cc23a239ac6af14a3897fd7c58faba25cb2fdc667ec6539655e35477b2d9b7cc5feaa6cc71c05e1e19d3a84cc26e754843686fe4135d78cb6ab9035c47c2c2005261fee668818d8c19110e211bd77de66cb90e39e5beba9a30d90dd7cd799290db4e4574a34eb5f1cddd079107c8fd14d53c7010c5db39b6a5498b58b1895f716bded3427c38828b6b5fe733855b84ca91ad8323541ee6ee57d56f393c490516a380a382f9cafc561a6ead8c1b037225b53f9df7b9a80f789e175a4731ea8e62c4d1eba99c5dda16152822a6ed22437c8ae5278ad039a35cd5b21026e0834b6770581fd71d23817c772c1b7a258d5ba414848cc25c31fc712d72517dbc8d83e3ac75cdc17f1da427d8a3aa394633ce87b2bb1741f0fcb7c2c89b2496b04dfde9193af1380561cf57af97ddccdefa625ce6e156cef618b31efe9fdb9b1977d91ede30e0c25d568db96c0500e0c29b8345163a181a28d6979af11a23a625c4e3f3122d605a895ee51fe6174e38e0c1c5928e7fc91d1ba3491dfeeba10c473c93c7167067485216a727fcfaf788dfdff54aaa195bcdfaf20ce328a8cdbec7036b82afc256289e59b828ae287c42f97f961edf0adcc303dc702f1522bbbf56de9ed0f14af58a6b1335cee3af19da0e09bb5cd50c981520501958c2053a396befc921938854c0c25d02f24b94e43b307fa97c6b50927bfc539c1289164737d7297343ab0d8351f4c1ff88369a6188ef2fddd791e2b1e5137f0e2a6caa7d343f909b1f14a6d838b8ec54d9ca6efd4c94204fdd212b5629cdcb0b1da0ac1be611616d92d67c1332e0dbc188f15e824aa3d588d31952412b3d33d94fdb2d24c4d01b74f00d6cf97effd336a4d064b22f54f304a70272270740e254dd3a6676f46d10b09b704ed985f6bc03ca67088d258a0a2cef42baa93d70a3c1e0ad67eda6455c0acbe0d83ecc06571c86802d0221546b1908d223de306172393339c2f31e7178f56573d461d38f89127ffd6fa8bf8eb5af17d441a3b73719ac961c90c758aba2a40794cc8622fc20f33568464ebb8a46279dc22b7558813633d517a7859fa199ea4c0925149d6207c51d7ed8db4020ad2f8ec8827973016a7ed4f7421e0430465ca023d2475a7f011ca303d6f50ca545c36a0d661a0d791735df98a8c0be6d2f5f3e45aaab847976e8d6d1e8d6d8fdef5a39673fcce748b38c038b6e45520be28c361988f6b84fc05a0237baf6c0be917d10ed9b4aa5d6ee30f3fdb013b9ed885d3a416349b9aa0055c0b72b74d34598484ffade6ce99576677d15c9963295096f3009346f159974508c0bbbf97a0b49e301a7244f66a7fc5db776e468658dc4415b045cacc98670f05557fab0128b154d4e2e83038183e571ade7e2bfd0c7094975fff8b65a41caee5e426bc85e8691b0aa40b8f683d02bb09cb491050ceff47d5d189c6250427fc2f3bda870a1a29bcf7e56e655b476abd575de8645d68ab48152a46787617def65efacf27054c8fbc590c4e210c7b3897b3aeb7edfa18cbb9c99ebd4626adab5cdbcb842722b775a3645d4dba8b502979c7a470dbf44efbc76d126eda10ac4baa073b35bb3f1d66c16483c18c21105d7b4653dfa4e9231e04c18878e1744d5b05bd243a6ce30159e279fba1a28aa860372104420430d7b21f45a53150c36af535206608e06f4531d34e8c2c27c7c7e98bd0bac78f0e76f713f9755dbc3f41dbf9e619b7ce4e23d1008c5503f453794bd08bb1712bd60123d07a2b00b24b07bc0a39039586de382ff1f506432c792178f983f1a09ab8f3a2198204bbe25f2bce6a024c914572a66a0a8713cabdeba17c3bdb037f111ae4f6ff904da48398825c8b89783634911c964599062928cad7e66ad39542e526874bb54fd98e404d4f1b153d5dd44e3a24f3f736ed9bed13e247be609b045b313de0129211effbe450d2830e0e634ac3d3e54be181b76120fb44086b3cf31404b0f8687700b4b148a37045ff0a0ad649ef402797bb1c8ad7dcceff056959ddf84d08bd27a5c25c21f2f2a79adb248dce4bf3c69873cd3523f687805d950f09ea3f2aa5c863650de62a3824b9480ee0b36dc521c4e4b3d2d2275e0fc48b9bbfc990bc2adf1ed609aaeca8c89b7f42d9e292868adbae5efd6bf93ed398438e8f96ce8b9394b4e7baf069cae7143876d31abc42c913a23d79ecdccc58c36b2385938fd34798b2323c608430bf652a00a9f5a942b1d302b4539fb229cf22d55ebbbe5238b0397c69e4d837b93f463cc044bf0e05f1f966e238bc1dbc529922dcca64a54b6eab6f9a22c086a2586767e1a9f2744bb2a23933405dbc5eff612ce4dc9099477d0a8602968410ce9edc8f0a96b339c4d998eb2e81df7fa711c3f560dfce772a80f9c7949435f87e35808ee7a9b7cc39e990ea21437eae16fd77c93d6e64d3bb1dba354fd3512ec4f86e7e967b70442108ed4c63d60de78fa2bb5be6aa3a38e58e5479852612369244fe219725a1d9cb0f104c690c0a8bb831035998394b703cdaa91e4bc2d739923db11b2452ed7d06835f309ea4a0d5c825a34c512a0fd412302d39421b1d61c37a4fd7b5d8107bf59432cd6253735f7ad74f2de1f462d12245a984588354fc0902f3c38925b87edbbf7be28d5b7c3c2e7dbc94fe48a2fefbc420b142b6bc850bd7c1495404e023629e574c5014fc2b11f78ddf963226f2e82aed2b91ae436c2d72125886c1137bd6fe775b3666a5b92620f95938c66894e43b04a97a3310a673b2d6ffa8066c6c1cca0f4f71bc322595b85c42e55e869c1b72fc9414d42a7c7631b8b24db104ebbf1e38264877999e2739ddd44c3954a29f33917172b09bc480667e23d626eca8db6bd5a7cc073ba7090455fa74c7bfb1bb1953ba9a153918d2ede37ffd582ca020eb9a4d7b6e5c3a2bf4cd38f66c2a5bc56fa77c7e5e7cfcbdff82ebe92c0a85b8d7a8e911bfd7fae3c46b75c44de2555218c7a45857220779a15d72f73b7bb73d3bece13769fc5c9370395a05b544ad905e9c2dbc9c8cbba9c2dba94815505932d56427eee2b868b050044bedc72c89812962a8572273d01298bbad79a5262b46961da2fa62672bc6dd8c0fae648a53949c4fe6b29fba4a617af8c9a61acba94628790231475701644f44b8281489ce6a369d600880cfc354757bb8ddfa3bdb49b663d2f74c73e4e45725e7cf39c4a1c1f5201881875756595a9da39abd5b2d249f3f6e8112483e0837ae225cbcbd45b2024a0d60502fe51c3c750e6d6bf75026dd1c36bdb2a75053631dde567621e3cf557b350a255e12af5539b71643c699d26a7872f47303fe53eecf098b20d15847fcdeb9a21a5e0ef43565bb28c5f4d9edb1cced5f9ef296d543b88eba292ba3dc3f6068ed68cddcdb2f7e87419dce79be11eb3e17c8433068e7749f6456fb9f2401e1aa8f47d590baa42e73f9df977daf6f66c7f498722b894137a5c1f7782c4c5c2e35abfc2454bb41d18f010ee5ac6cac86424fd4636435d289b20b0ee8d2cbc3eed84ec76eac266796c5d27ee48cf48d0b366cdee89a5c8191adcd3888e723ef189fbd1f337cc3cacc0ed45f9dd2076b387ae67e480ad94c757fc6b4a3763a10baf134a8238bd70874d16693caee3458a6390420672817bb474ebe63c0603a99f83bbdeca2be44d3dec06b72ef083a062b249432e0c14f6a8fb70675c8ebbd10d7ff6362cb6ade170099dbac7c148acfbaafd61943694f278f5f37576a7271c0bf6bc91db779a6595bebaf3a73a7c8231101ad7513c2437874f3eaa52c8ae1601f74c17a4164cebe96707f2d51255e98bbeed987cbe39809bd82d239ae05e0804b8b649cf062f1595bdaa4f3a22e697a4102f707ce750b3fa3cd10c0815fe512e7c9efdaf712d6a84e63fb47d53040d73b8bee5032e31e898b644119337df5b99a1159062efacfb1347a49f253a4b0a2de8b19000ede20913ad3c26e0b6d057a07d117c77d7c6b979830ce10e4e8a0ed5dd3c914b30a336df4557bfd7fc8de16130c82530235754efd7883a3637859bd97a920f2fc3bd21aa00a4611b3bd5a0283197e549db3f26811657f6c3d5f0e6fd95b2c0b6907764a7a7bd9247dc3024afbf308581e09e3a9722bc5c717a69f419d50d97fa12aedc5ad0f602d72da6aa3a1733564b180c0c2b7990255d21f8fa826f72568544dd3afb0173b837d6ecacd440a5a416767d20655fae69439b5ee8fa36df1d1297361f73f813eb80cb7afdeb193169c2fa961deadd26ddb90d0351a23d1f3ef089fd4e7d4003679c570c64926827f055d78ef8b6e73013cecea119029a3a15dcb3ccf742e82f43949756d04760cd164b79726dcd68570e088dd130da69bb1c560ed4c733e47b28aff2b6121a0760fa1086aa5f2b63481cf2c639ca8bfdc14bab75fa6780521552a9ad31615919c691438ba9133e49a87cf609539bbd8c4cf621cdf0a1a7e80d39688c4d70926e092642cfd2bbfc68ac5035a283da481741d6cbc1b9d079b56a76f11b78ab4f119994d6a1071d18ae8a4f2e929d3fe5e9f15a1cfdf7451260124c83f4a1731d00314ba8689e4b4e6f334e29d2ef3d702d28e563e4436e6b038d5944fd5bba37098b12017efd137c01ee7b587eca1b45f263efa8adbce970662f1fbde165349200432ece0f9c59abc5099b53a292ce77fa1b3ad86b2a9da6bff484654b80aba151e82f5ff4c2799cbe8dda1b1a851b79ab984fdffedf16a83165a1cd3eac5f601cfbb1060a8175ac9f0cf17b8fc5bf982db7c3ffc4fd3b6d51359c06a2f8cac4e9c79631a9df261b65a651ca47d5a6572c0c2957f28a21d5ccf86498588bcf820a7d761e9bc0775e06e88dccbe8d4a8f0b8dda74c78aca2d1decd39e18e7f5d93446e82608096358b4a40a9\n  \n    \n      \n      \n        您好, 这里需要密码.\n      \n      \n        \n        \n      \n    \n  \n\n","categories":["干货"],"tags":["Interview"]},{"title":"acwing基础算法(1)：基础算法","url":"/2022/02/22/algorithm/acwing/%E5%9F%BA%E7%A1%80%E8%AF%BE/L1-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/","content":"快速排序\nAcWing 785. 快速排序\n\n#include&lt;iostream&gt;using namespace std;const int N = 1e6+10;int q[N];void quick_sort(int q[], int l, int r){    if(l&gt;=r) return;    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while(i &lt; j){        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i&lt;j) swap(q[i], q[j]);    }    quick_sort(q, l, j);    quick_sort(q, j + 1, r);}int main(){    int n;    scanf(\"%d\", &amp;n);    for(int i=0;i&lt;n;i++) scanf(\"%d\", &amp;q[i]);    quick_sort(q, 0, n-1);    for(int i=0;i&lt;n;i++) printf(\"%d \", q[i]);}\n\nAcWing 786. 第k个数\n\n#include&lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int q[N];void quick_sort(int q[], int l, int r){    if(l &gt;=r) return;    int i = l-1, j = r + 1, x = q[l + r&gt;&gt;1];    while(i&lt;j){        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i&lt;j) swap(q[i], q[j]);    }    quick_sort(q, l, j), quick_sort(q, j + 1, r);}int main(){        int n,k;    scanf(\"%d%d\", &amp;n, &amp;k);        for(int i = 0; i &lt; n; i ++ ) scanf(\"%d\", &amp;q[i]);        quick_sort(q, 0, n-1);    printf(\"%d\", q[k-1]);        return 0;}\n归并排序\nAcWing 787. 归并排序 \n\n#include&lt;iostream&gt;using namespace std;const int N = 1e6+10;int q[N], tmp[N];void merge_sort(int q[], int l, int r){    if(l &gt;=r) return;    int mid = l+r&gt;&gt;1;    merge_sort(q, l, mid);    merge_sort(q, mid+1, r);        int k=0, i=l, j=mid+1;    while(i&lt;=mid &amp;&amp; j&lt;=r){        if(q[i] &lt;= q[j])             tmp[k++] = q[i++];        else            tmp[k++] = q[j++];    }    while(i&lt;=mid) tmp[k++] = q[i++];    while(j&lt;=r) tmp[k++] = q[j++];    for(int i=l, j=0;i&lt;=r;i++,j++) q[i] = tmp[j];}int main(){        int n;    scanf(\"%d\", &amp;n);    for(int i=0;i&lt;n;i++) scanf(\"%d\", &amp;q[i]);        merge_sort(q, 0, n-1);        for(int i=0;i&lt;n;i++) printf(\"%d \", q[i]);        return 0;}\n\nAcWing 788. 逆序对的数量\n\n#include&lt;iostream&gt;using namespace std;const int N = 1e6+10;int n;int q[N], tmp[N];typedef long long LL;LL merge_sort(int l, int r){    if(l&gt;=r) return 0;    int mid = l+r&gt;&gt;1;    LL res = merge_sort(l, mid) + merge_sort(mid+1, r);    int k=0, i=l,j=mid+1;    while(i&lt;=mid &amp;&amp; j&lt;=r){        if(q[i]&lt;=q[j])            tmp[k++] = q[i++];        else{            tmp[k++] = q[j++];            res += mid - i + 1;        }    }    while(i&lt;=mid) tmp[k++] = q[i++];    while(j&lt;=r) tmp[k++] = q[j++];    for(int i=l, j=0;i&lt;=r;i++,j++) q[i] = tmp[j];    return res;}int main(){    cin &gt;&gt; n;    for(int i=0;i&lt;n;i++) cin&gt;&gt;q[i];    cout &lt;&lt;  merge_sort(0, n-1) &lt;&lt; endl;    return 0;}\n二分\nAcWing 789. 数的范围 \n\n#include&lt;iostream&gt;using namespace std;const int N=1e6+10;int q[N];int main(){        int n, m;    scanf(\"%d%d\", &amp;n, &amp;m);    for(int i=0;i&lt;n;i++) cin &gt;&gt; q[i];        while(m--){        int x;        cin &gt;&gt; x;                int l = 0, r = n - 1;        while(l &lt; r){            int mid = l + r &gt;&gt; 1;            if(q[mid] &gt;= x) r = mid;            else                l = mid + 1;        }        if(q[l] != x)            cout &lt;&lt; \"-1\" &lt;&lt; \" \";        else            cout &lt;&lt; l &lt;&lt; \" \";                l = 0, r = n - 1;        while(l &lt; r){            int mid = l + r + 1 &gt;&gt; 1;            if(q[mid] &lt;= x) l = mid;            else                r = mid - 1;        }        if(q[r] != x)            cout &lt;&lt; \"-1\" &lt;&lt; endl;        else            cout &lt;&lt; l &lt;&lt; endl;    }        return 0;}\n\nAcWing 790. 数的三次方根\n\n#include&lt;iostream&gt;using namespace std;int main(){        double n;    cin &gt;&gt; n;            double l = -10000, r = 10000;    while(r - l &gt; 1e-8){        double mid = (l + r) / 2 ;        if(mid * mid * mid &gt;= n) r = mid;        else            l = mid;    }    printf(\"%.6f\", l);    return 0;}\n高精度\nAcWing 791. 高精度加法 \n\n#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; add(vector&lt;int&gt;&amp;A, vector&lt;int&gt;&amp;B){    vector&lt;int&gt;C;    int t = 0;    for(int i = 0; i &lt; A.size() || i &lt; B.size(); i++){        if(i &lt; A.size()) t += A[i];        if(i &lt; B.size()) t += B[i];        C.push_back(t % 10);        t /= 10;    }    if(t) C.push_back(t);    return C;}int main(){    string a, b;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt;A,B;    for(int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - '0');    for(int i = b.size() - 1; i &gt;= 0; i--) B.push_back(b[i] - '0');        vector&lt;int&gt; C = add(A, B);        for(int i = C.size() - 1; i &gt;= 0; i--) printf(\"%d\", C[i]);        return 0;}\n\nAcWing 792. 高精度减法 \n\n#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// A 是否大于 Bbool cmp(vector&lt;int&gt;&amp;A, vector&lt;int&gt;&amp;B){    if(A.size() != B.size()) return A.size() &gt; B.size();    for(int i = A.size() - 1; i &gt;= 0; i--){        if(A[i] != B[i])            return A[i] &gt; B[i];    }    return true;}vector&lt;int&gt; sub(vector&lt;int&gt;&amp;A, vector&lt;int&gt;&amp;B){    vector&lt;int&gt; C;    int t = 0;    for(int i = 0; i &lt; A.size(); i++){        t = A[i] - t;        if(i &lt; B.size()) t -= B[i];        C.push_back((t + 10) % 10);        if(t &lt; 0) t = 1;        else            t = 0;    }    //删除先导0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;}int main(){    string a, b;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt;A,B;    for(int i = a.size() - 1; i &gt;= 0; i--) A.push_back(a[i] - '0');    for(int i = b.size() - 1; i &gt;= 0; i--) B.push_back(b[i] - '0');        if(cmp(A, B)){        vector&lt;int&gt; C = sub(A, B);        for(int i = C.size() - 1; i &gt;= 0; i--) printf(\"%d\", C[i]);    }else{        vector&lt;int&gt; C = sub(B, A);        printf(\"-\");        for(int i = C.size() - 1; i &gt;= 0; i--) printf(\"%d\", C[i]);    }    return 0;}\n\nAcWing 793. 高精度乘法\n\n//高精度乘法#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt;&amp;A, int b){    vector&lt;int&gt;C;    int t = 0;    for(int i = 0;i&lt;A.size();i++){        t += A[i] * b;        C.push_back(t % 10);        t /= 10;    }    if(t) C.push_back(t);        // 删除前导0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();        return C;}int main(){    string a;    int B;    cin &gt;&gt; a &gt;&gt; B;    vector&lt;int&gt; A;    for(int i = a.size()-1;i&gt;=0;i--) A.push_back(a[i] - '0');        vector&lt;int&gt; C = mul(A, B);        for(int i = C.size()-1;i&gt;=0;i--) cout &lt;&lt; C[i];    }\n\nAcWing 794. 高精度除法\n\n#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt;&amp;A, int b, int &amp;r){    vector&lt;int&gt; C;    for(int i = A.size()-1; i&gt;=0; i--){        r = r * 10 + A[i];        // cout &lt;&lt; \"r: \" &lt;&lt; r &lt;&lt; endl;        C.push_back(r / b);        r %= b;    }    // for(auto x:C) cout &lt;&lt; x;        reverse(C.begin(), C.end());    //删除前导0    while(C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;}int main(){    string a;    int b;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt; A;    for(int i = a.size()-1; i &gt;= 0; i--) A.push_back(a[i] - '0');        int r = 0;    vector&lt;int&gt; C = div(A, b, r);        for(int i = C.size()-1; i &gt;= 0; i--) cout &lt;&lt; C[i];    cout &lt;&lt; endl &lt;&lt; r;    return 0;}\n前缀和与差分\nAcWing 795. 前缀和\n#include&lt;iostream&gt;using namespace std;const int N = 1e6+10;int a[N], s[N];int main(){        int n, m;    scanf(\"%d%d\", &amp;n, &amp;m);    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];    for(int i = 1; i &lt;= n; i++) s[i] = s[i-1] + a[i];    while(m--){        int l, r;        scanf(\"%d%d\", &amp;l, &amp;r);        cout &lt;&lt; s[r] - s[l-1] &lt;&lt; endl;    }        return 0;}\n\n\n\nAcWing 796. 子矩阵的和\n\n#include&lt;iostream&gt;using namespace std;const int N = 1010;int a[N][N], s[N][N];int n,m,q;int main(){        cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;    for(int i = 1;i&lt;=n;i++)        for(int j = 1;j&lt;=m;j++)            cin &gt;&gt; a[i][j], s[i][j] = a[i][j] + s[i-1][j] + s[i][j-1] - s[i-1][j-1];         while(q--){        int x1, y1, x2, y2;        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;        cout &lt;&lt; s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] &lt;&lt; endl;;    }    return 0;}\n\nAcWing 797. 差分\n\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int a[N], b[N];int n, m ;void insert(int l, int r, int c){    b[l] += c;    b[r + 1] -= c;}int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i];    for(int i = 1; i &lt;= n; i++) insert(i, i, a[i]);    while(m--){        int l, r, c;        cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;        insert(l, r, c);    }    for(int i = 1; i &lt;= n;i++ ) a[i] = a[i-1] + b[i], cout &lt;&lt; a[i] &lt;&lt; \" \";    }\n\nAcWing 798. 差分矩阵\n\n#include&lt;iostream&gt;using namespace std;const int N = 1010;int a[N][N], b[N][N];int n, m, q;void insert(int x1, int y1, int x2, int y2, int c){    b[x1][y1] += c;    b[x1][y2 + 1] -= c;    b[x2 + 1][y1] -= c;    b[x2 + 1][y2 + 1] += c;}int main(){        cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;    for(int i = 1; i &lt;= n; i++)        for(int j = 1; j &lt;= m; j++) cin &gt;&gt; a[i][j];        for(int i = 1; i &lt;= n; i++)        for(int j = 1; j &lt;= m; j++) insert(i, j, i, j, a[i][j]);        while(q--){        int x1, y1, x2, y2, c;        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;        insert(x1, y1, x2, y2, c);    }    for(int i = 1; i&lt;= n; i++){        for(int j = 1;j &lt;= m; j++){            a[i][j] = b[i][j] + a[i-1][j] + a[i][j-1] - a[i-1][j-1];            cout &lt;&lt; a[i][j] &lt;&lt; \" \";        }        cout &lt;&lt; endl;    }        return 0;}\n双指针算法\nAcWing 799. 最长连续不重复子序列\n\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int a[N], s[N];int n;int main(){    cin &gt;&gt; n;    for(int i = 0; i&lt;n; i++) cin &gt;&gt; a[i];    int res = 0;    for(int i = 0, j = 0; i &lt; n; i ++){        s[a[i]]++;        while(s[a[i]] &gt; 1){            s[a[j]]--;            j++;        }        res = max(res, i - j + 1);    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}\n\nAcWing 800. 数组元素的目标和 \n\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int a[N], b[N];int n, m, x;int main(){        cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;    for(int i = 0;i&lt;n;i++) cin &gt;&gt; a[i];    for(int i = 0;i&lt;m;i++) cin &gt;&gt; b[i];        //双指针    for(int i=0, j=m-1;i&lt;n;i++){        while(j &gt;=0  &amp;&amp; a[i]+b[j] &gt; x) j--;        if(a[i] + b[j] == x){            cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; j &lt;&lt; endl;            break;        }    }        return 0;}\n\nAcWing 2816. 判断子序列\n\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int A[N], B[N];int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i=0;i&lt;n;i++) cin &gt;&gt; A[i];    for(int i=0;i&lt;m;i++) cin &gt;&gt; B[i];    // int i = 0;    // for(int j = 0;j&lt;m;j++){    //     if(i&lt;n &amp;&amp; A[i] == B[j]) i++;    // }    // if(i == n) cout &lt;&lt; \"Yes\" &lt;&lt; endl;    // else cout &lt;&lt; \"No\" &lt;&lt; endl;    int i, j=0;    for(i=0;i&lt;n;i++){        while(j &lt; m &amp;&amp; A[i] != B[j]) j++;        if(j == m) break;        else j++;    }    if(i == n) puts(\"Yes\");    else puts(\"No\");        return 0;}\n位运算\nAcWing 801. 二进制中1的个数\n\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int a[N], res[N];int lowbit(int &amp;x){    return x&amp;-x;}int main(){        int n;    cin &gt;&gt; n;    for(int i = 0;i &lt; n; i++) cin &gt;&gt; a[i];        for(int i=0;i&lt;n;i++){        int res = 0;        while(a[i]) a[i] -= lowbit(a[i]), res++;        cout &lt;&lt; res &lt;&lt; \" \";    }    cout &lt;&lt; endl;        return 0;}\n离散化\nAcWing 802. 区间和\n\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 300010;int a[N], s[N];typedef pair&lt;int, int&gt; PII;vector&lt;int&gt; alls;vector&lt;PII&gt; adds, quires;int find(int x){    int l = 0, r = alls.size() - 1;    while (l &lt; r){        int mid = l + r &gt;&gt; 1;        if (alls[mid] &gt;= x) r = mid;        else l = mid + 1;    }    return l + 1;}int main(){    int n, m;    cin &gt;&gt; n &gt;&gt; m;        for (int i = 0; i &lt; n; i ++ ){        int x, c;        cin &gt;&gt; x &gt;&gt; c;        alls.push_back(x);        adds.push_back({x, c});    }    for (int i = 0; i &lt; m; i ++ ){        int l, r;        cin &gt;&gt; l &gt;&gt; r;        quires.push_back({l, r});        alls.push_back(l);        alls.push_back(r);    }    // 去重    sort(alls.begin(), alls.end());    alls.erase(unique(alls.begin(), alls.end()), alls.end());        for (auto item : adds){        int x = find(item.first);        a[x] += item.second;    }        for (int i = 1; i &lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];        for (auto item : quires){        int l = find(item.first);        int r = find(item.second);        cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl;    }    return 0;}\n区间合并\nAcWing 803. 区间合并\n\n#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N = 100010;int n;int main(){    cin &gt;&gt; n;    vector&lt;PII&gt; segs;    vector&lt;PII&gt; res;    while(n--){        int l, r;        cin &gt;&gt; l &gt;&gt; r;        segs.push_back({l,r});    }        sort(segs.begin(), segs.end());    int st = -2e9, ed = -2e9;    for(auto seg : segs){        if(ed &lt; seg.first){            if(st!=-2e9) res.push_back({st, ed});            st = seg.first, ed = seg.second;        }        else            ed = max(ed, seg.second);    }    if(st!=2e9) res.push_back({st, ed});    cout &lt;&lt; res.size() &lt;&lt; endl;        return 0;}\n","categories":["算法与数据结构"],"tags":["acwing","算法模板题"]},{"title":"acwing基础算法(2)：数据结构","url":"/2022/02/22/algorithm/acwing/%E5%9F%BA%E7%A1%80%E8%AF%BE/L2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"单链表\nAcWing 826. 单链表\n\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int e[N], ne[N], head, idx;void init(){    head = -1;    idx = 0;}void add_head(int x){        e[idx] = x, ne[idx] = head, head = idx ++;}void insert(int k, int x){    e[idx] = x;    ne[idx] = ne[k];    ne[k] = idx++;}void remove(int k){        ne[k] = ne[ne[k]];}int main(){        init();    int m;    cin &gt;&gt; m;    while(m --){        char op;        int k, x;        cin &gt;&gt; op;        if(op == 'H'){            cin &gt;&gt; x;            add_head(x);        }                if(op == 'I'){            cin &gt;&gt; k &gt;&gt; x;            insert(k-1, x);        }                if(op == 'D'){            cin &gt;&gt; k;            if(!k) head = ne[head];            else remove(k-1);        }    }    for(int i=head; i!=-1;i=ne[i])        cout &lt;&lt; e[i] &lt;&lt; ' ';        return 0;}\n双链表\nAcWing 827. 双链表\n\n#include&lt;iostream&gt;using namespace std;const int N = 100010;int e[N], l[N], r[N], idx;void insert(int k, int x){    // k的右侧插入x    e[idx] = x;    l[idx] = k, r[idx] = r[k];    l[r[k]] = idx, r[k] = idx++;}void remove(int k){    l[r[k]] = l[k];    r[l[k]] = r[k];}int main(){       r[0] = 1, l[1] = 0;    idx = 2;    int m;    cin &gt;&gt; m;    while(m--){        string op;        int k, x;        cin &gt;&gt; op;        if(op == \"L\"){            cin &gt;&gt; x;            insert(0, x);        }        if(op == \"R\"){            cin &gt;&gt; x;            insert(l[1], x);        }        if(op == \"D\"){            cin &gt;&gt; k;            remove(k + 1);        }        if(op == \"IL\"){            cin &gt;&gt; k &gt;&gt; x;            insert(l[k + 1], x);        }        if(op == \"IR\"){            cin &gt;&gt; k &gt;&gt; x;            insert(k + 1, x);        }    }    for(int i = r[0]; i != 1; i = r[i]){        // cout &lt;&lt; i &lt;&lt; ' ';        cout &lt;&lt; e[i] &lt;&lt; ' ';        // break;    }            cout &lt;&lt; endl;    return 0;}\n栈\nAcWing 828. 模拟栈 \n\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int stk[N], tt=0;int main(){    int m;    cin &gt;&gt; m;    while (m -- ){        string op;        int x;        cin &gt;&gt; op;        if(op == \"push\"){            cin &gt;&gt; x;            stk[++tt] = x;        }        if(op == \"pop\"){            tt--;        }        if(op == \"empty\"){            if(tt &gt; 0)                cout &lt;&lt; \"NO\" &lt;&lt; endl;            else                cout &lt;&lt; \"YES\" &lt;&lt; endl;        }        if(op == \"query\"){            cout &lt;&lt; stk[tt] &lt;&lt; endl;        }            }        return 0;}\n\nAcWing 3302. 表达式求值 (不会写)\n\n队列\nAcWing 829. 模拟队列\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int q[N], hh=0, tt=-1;int main(){    int m;    cin &gt;&gt; m;    while (m -- ){        string op;        int x;        cin &gt;&gt; op;        if(op == \"push\"){            cin &gt;&gt; x;            q[++tt] = x;        }        if(op == \"pop\"){            hh++;        }        if(op == \"empty\"){            if(hh &lt;= tt)                cout &lt;&lt; \"NO\" &lt;&lt; endl;            else                cout &lt;&lt; \"YES\" &lt;&lt; endl;        }        if(op == \"query\"){            cout &lt;&lt; q[hh] &lt;&lt; endl;        }    }    return 0;}\n单调栈\nAcWing 830. 单调栈\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int a[N], stk[N], tt = 0;int main(){        int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i ++ ) scanf(\"%d\", &amp;a[i]);    // 单调栈    for (int i = 0; i &lt; n; i ++ ){        while(tt &amp;&amp; stk[tt] &gt;= a[i]) tt--;        if(tt == 0)            cout &lt;&lt; -1 &lt;&lt; ' ';        else            cout &lt;&lt; stk[tt] &lt;&lt; ' ';        stk[++tt] = a[i];    }        return 0;}\n单调队列\nAcWing 154. 滑动窗口\n\n#include &lt;iostream&gt;using namespace std;const int N = 1000010;int q[N], a[N];int main(){    int n, k;    scanf(\"%d%d\", &amp;n, &amp;k);    for (int i = 0; i &lt; n; i ++ ) scanf(\"%d\", &amp;a[i]);            int hh = 0, tt = -1;    for (int i = 0; i &lt; n; i ++ ){        if (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++;        while (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;        q[++tt] = i;        if (i - k + 1 &gt;= 0) cout &lt;&lt; a[q[hh]] &lt;&lt; ' ';    }    cout &lt;&lt; endl;    hh = 0, tt = -1;    for (int i = 0; i &lt; n; i ++ ){        if (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++;        while (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;        q[++tt] = i;        if (i - k + 1 &gt;= 0)  cout &lt;&lt; a[q[hh]] &lt;&lt; ' ';    }    return 0;}\nkmp\nAcWing 831. KMP字符串\n\n#include &lt;iostream&gt;using namespace std;const int N = 100010;const int M = 1000010;char p[N], s[M];int ne[N];int n, m;int main(){    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;        // 构造ne    for (int i = 2, j = 0; i &lt;= n; i ++ ){        while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];        if (p[i] == p[j + 1]) j ++;        ne[i] = j;    }        // 匹配    for (int i = 1, j = 0; i &lt;= m; i ++){        while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];        if (s[i] == p[j + 1]) j ++;        if (j == n){            cout &lt;&lt; i - n &lt;&lt; ' ';            j = ne[j];        }    }        return 0;}\nTrie\nAcWing 835. Trie字符串统计\n\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int son[N][26], cnt[N], idx;int insert(char s[]){    int p = 0;    for (int i = 0; s[i]; i ++){        int u = s[i] - 'a';        if (!son[p][u]) son[p][u] = ++ idx;        p = son[p][u];    }    cnt[p] ++;    return 0;}int query(char s[]){    int p = 0;    for (int i = 0; s[i]; i ++){        int u = s[i] - 'a';        if (!son[p][u]) return 0;        p = son[p][u];    }    return cnt[p];}int main(){    int n;    scanf(\"%d\", &amp;n);    while (n --){        char op[2], s[N];        scanf(\"%s%s\", op, s);        if (op[0] == 'I') insert(s);        else cout &lt;&lt; query(s) &lt;&lt; endl;    }        return 0;}\n\nAcWing 143. 最大异或对\n\n#include &lt;iostream&gt;using namespace std;const int N = 100010;const int M = 3100010;int a[N];int son[M][2], cnt[M], idx;void insert(int num){    int p = 0;    for (int i = 30; i &gt;= 0; i --){        int u = num &gt;&gt; i &amp; 1;        if (!son[p][u]) son[p][u] = ++ idx;        p = son[p][u];    }    cnt[p] ++;}int query(int num){    int p = 0, res = 0;    for (int i = 30; i &gt;= 0; i --){        int u = num &gt;&gt; i &amp; 1;        if (son[p][!u]) {            p = son[p][!u];            res += 1 &lt;&lt; i;        } else p = son[p][u];    }    return res;}int main(){    int n, r = 0;    scanf(\"%d\", &amp;n);    for (int i = 0; i &lt; n; i ++ ) scanf(\"%d\", &amp;a[i]), insert(a[i]);    for (int i = 0; i &lt; n; i ++ ) r = max(r, query(a[i]));    printf(\"%d\", r);    return 0;}\n并查集\nAcWing 836. 合并集合\n\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int p[N], n, m;int find(int x){    if (p[x] != x) p[x] = find(p[x]);    return p[x];}int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    while (m -- ) {        int a, b;        char op[2];        scanf(\"%s%d%d\", op, &amp;a, &amp;b);                if( op[0] == 'M'){            if (find(a) == find(b)) continue;            p[find(a)] = find(b);        }else if (op[0] == 'Q'){            if(find(a) == find(b)) cout &lt;&lt; \"Yes\" &lt;&lt; endl;            else cout &lt;&lt; \"No\" &lt;&lt; endl;        }    }    return 0;}\n\nAcWing 837. 连通块中点的数量\n\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int p[N], cnt[N];int find(int x){    if(p[x] != x) p[x] = find(p[x]);    return p[x];}int main(){    int n, m;    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ ) p[i] = i, cnt[i] = 1;    while (m -- ){        int a, b;        string op;        cin &gt;&gt; op;        if(op == \"C\"){            scanf(\"%d%d\", &amp;a, &amp;b);            if(find(a) == find(b)) continue;            cnt[find(b)] += cnt[find(a)];            p[find(a)] = find(b);                    }else if(op == \"Q1\"){            scanf(\"%d%d\", &amp;a, &amp;b);            if(find(a) == find(b)) cout &lt;&lt; \"Yes\" &lt;&lt; endl;            else cout &lt;&lt; \"No\" &lt;&lt; endl;                    }else if (op == \"Q2\"){            scanf(\"%d\", &amp;a);            cout &lt;&lt; cnt[find(a)] &lt;&lt; endl;        }    }            return 0;}\n\nAcWing 240. 食物链 (不会写)\n\n堆\nAcWing 838. 堆排序\n\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int h[N], cnt;void down(int u){    int t = u;    if (u * 2 &lt;= cnt &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if (u * 2 + 1 &lt;= cnt &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if (u != t){        swap(h[u], h[t]);        down(t);    }}void up(int u){    }int main(){    int n, m;    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ ) scanf(\"%d\", &amp;h[i]);    cnt = n;    for (int i = n / 2; i; i --) down(i);        while (m -- ) {        printf(\"%d \", h[1]);        h[1] = h[cnt --];        down(1);    }        return 0;}\n\nAcWing 839. 模拟堆\n\n#include &lt;iostream&gt;using namespace std;const int N = 100010;int h[N], cnt, m, hp[N], ph[N];void heap_swap(int a, int b){    swap(ph[hp[a]], ph[hp[b]]);    swap(hp[a], hp[b]);    swap(h[a], h[b]);}void down(int u){    int t = u;    if (2 * u &lt;= cnt &amp;&amp; h[2 * u] &lt; h[t]) t = 2 * u;    if (2 * u + 1 &lt;= cnt &amp;&amp; h[2 * u + 1] &lt; h[t]) t = 2 * u + 1;    if (u != t){        heap_swap(t, u);        down(t);    }}void up(int u){    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2]){        heap_swap(u / 2, u);        u &gt;&gt;= 1;    }}int main(){        int n;    scanf(\"%d\", &amp;n);    while (n -- ) {        string op;        int k, x;        cin &gt;&gt; op;        if (op == \"I\"){            cin &gt;&gt; x;            m ++;            cnt ++;            ph[m] = cnt, hp[cnt] = m;            h[cnt] = x;            up(cnt);        }        else if (op == \"PM\"){            cout &lt;&lt; h[1] &lt;&lt; endl;        }        else if (op == \"DM\"){            heap_swap(1, cnt);            cnt --;            down(1);        }        else if (op == \"D\"){            cin &gt;&gt; k;            k = ph[k];            heap_swap(k, cnt);            cnt --;            up(k);            down(k);        }        else if (op == \"C\"){            cin &gt;&gt; k &gt;&gt; x;            k = ph[k];            h[k] = x;            up(k);            down(k);        }    }        return 0;}\nHash表\nAcWing 840. 模拟散列表\n\n// 拉链法#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int N = 100003;int h[N], e[N], ne[N], idx;void insert(int x){    int k = (x % N + N) % N;    e[idx] = x;    ne[idx] = h[k];    h[k] = idx ++;}bool find(int x){    int k = (x % N + N) % N;    for (int i = h[k]; i != -1; i = ne[i]){        if (e[i] == x) return true;    }    return false;}int main(){    int n;    scanf(\"%d\", &amp;n);    memset(h, -1, sizeof h);    while (n -- ) {        string op;        int x;        cin &gt;&gt; op &gt;&gt; x;        if (op == \"I\") insert(x);        else if (op == \"Q\"){            if(find(x)) cout &lt;&lt; \"Yes\" &lt;&lt; endl;            else cout &lt;&lt; \"No\" &lt;&lt; endl;        }    }    return 0;}\n\nAcWing 841. 字符串哈希\n\n#include &lt;iostream&gt;using namespace std;typedef unsigned long long ULL;const int N = 200003, P = 131;char s[N];ULL h[N], p[N];int get(int l, int r){    return h[r] - h[l - 1] * p[r - l + 1];}int main(){        int n, m;    scanf(\"%d%d\", &amp;n, &amp;m);    scanf(\"%s\", s + 1);        p[0] = 1;    for (int i = 1; i &lt;= n; i ++ ){        h[i] = h[i - 1] * P + s[i];        p[i] = p[i - 1] * P;    }    while (m -- ) {        int l1, r1, l2, r2;        scanf(\"%d%d%d%d\", &amp;l1, &amp;r1, &amp;l2, &amp;r2);        if (get(l1, r1) == get(l2, r2)) puts(\"Yes\");        else puts(\"No\");    }        return 0;}","categories":["算法与数据结构"],"tags":["acwing","算法模板题"]},{"title":"acwing基础算法(4)：数学知识","url":"/2022/02/22/algorithm/acwing/%E5%9F%BA%E7%A1%80%E8%AF%BE/L4-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/","content":"质数\nAcWing 866. 试除法判定质数\n\n#include &lt;iostream&gt;using namespace std;bool is_prime(int n){    if (n &lt; 2) return false;    for (int i = 2; i &lt;= n / i; i ++){        if (n % i == 0) return false;    }    return true;}int main(){    int n;    scanf(\"%d\", &amp;n);    while (n -- )    {        int x;        scanf(\"%d\", &amp;x);        if (is_prime(x)) puts(\"Yes\");        else puts(\"No\");    }        return 0;}\n\nAcWing 867. 分解质因数\n\n#include &lt;iostream&gt;using namespace std;void divided(int n){    for (int i = 2; i &lt;= n / i; i ++)    {        if (n % i == 0)        {            int s = 0;            while (n % i == 0) n /= i, s ++;            cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; s &lt;&lt; endl;        }    }    if (n &gt; 1) cout &lt;&lt; n &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl;    cout &lt;&lt; endl;}int main(){        int n;    cin &gt;&gt;n;    while (n -- ){        int x;        cin &gt;&gt; x;        divided(x);    }        return 0;}\n\nAcWing 868. 筛质数\n\n朴素筛法#include &lt;iostream&gt;using namespace std;const int N = 1000010;int primes[N], cnt;bool st[N];int count(int n){    for (int i = 2; i &lt;= n; i ++)    {        if (st[i]) continue;        primes[cnt ++] = i;        for (int j = i + i; j &lt;= n; j += i) st[j] = true;    }    return cnt;}int main(){    int n;    cin &gt;&gt; n;    cout &lt;&lt; count(n) &lt;&lt; endl;    return 0;}\n线性筛法#include &lt;iostream&gt;using namespace std;const int N = 1000010;int primes[N], cnt;bool st[N];// 线性筛法void count(int n){    for (int i = 2; i &lt;= n; i ++)    {        if (!st[i]) primes[cnt ++] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        {            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        }    }}int main(){    int n;    cin &gt;&gt; n;    count(n);    cout &lt;&lt; cnt &lt;&lt; endl;    return 0;}\n约数\nAcWing 869. 试除法求约数\n\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; get_divisors(int n){    vector&lt;int&gt; res;    for (int i = 1; i &lt;= n / i; i ++ )    {        if (n % i == 0)        {            res.push_back(i);            if ( i != n / i) res.push_back(n / i);        }    }    sort(res.begin(), res.end());    return res;}int main(){    int n;    cin &gt;&gt; n;    while (n -- )    {        int x;        cin &gt;&gt; x;        auto res = get_divisors(x);        for (auto c : res) cout &lt;&lt; c &lt;&lt; ' ';        puts(\"\");    }        return 0;}\n\nAcWing 870. 约数个数\n\n#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;typedef long long LL;const int N = 1e9 + 7;int main(){    int n;    cin &gt;&gt; n;    unordered_map&lt;int, int&gt; primes;    while (n -- )    {        int x;        cin &gt;&gt;x;        for (int i = 2; i &lt;= x / i; i ++)        {            while (x % i == 0)            {                x /= i;                primes[i] ++;            }        }        if (x &gt; 1) primes[x] ++;    }    LL res = 1;    for (auto c : primes)    {        res = res * (c.second + 1) % N;    }    cout &lt;&lt; res &lt;&lt; endl;}\n\nAcWing 871. 约数之和\n\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;typedef long long LL;const int mod = 1e9 + 7;int main(){    int n;    cin &gt;&gt; n;    unordered_map&lt;int, int&gt; primes;    while (n -- )    {        int x;        cin &gt;&gt; x;        for (int i = 2; i &lt;= x / i; i ++)        {            while (x % i == 0) x /= i, primes[i] ++;        }        if (x &gt; 1) primes[x] ++;    }        LL res = 1;    for (auto p : primes)    {        LL a = p.first, b = p.second;        LL t = 1;        while (b --) t = (t * a + 1) % mod;        res = res * t % mod;    }    cout &lt;&lt; res &lt;&lt; endl;            return 0;}\n\nAcWing 872. 最大公约数\n\n#include &lt;iostream&gt;using namespace std;int gcd(int a, int b){    return b? gcd(b, a % b) : a;}int main(){    int n;    cin &gt;&gt; n;    while (n -- )    {        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; gcd(a, b) &lt;&lt; endl;    }    return 0;}\n欧拉函数\nAcWing 873. 欧拉函数\n\nAcWing 874. 筛法求欧拉函数\n\n\n快速幂\nAcWing 875. 快速幂\n\n#include &lt;iostream&gt;using namespace std;typedef long long LL;LL qmi(int a, int k, int p){    LL res = 1 % p;    while (k)    {        if (k &amp; 1) res = res * (LL)a % p;        a = a * (LL) a % p;        k &gt;&gt;= 1;    }    return res;}int main(){    int n;    scanf(\"%d\", &amp;n);    while (n -- )    {        int a, k, p;        scanf(\"%d%d%d\", &amp;a, &amp;k, &amp;p);        printf(\"%d\\n\", qmi(a, k, p));    }    return 0;}\n\nAcWing 876. 快速幂求逆元\n\n扩展欧几里得算法\nAcWing 877. 扩展欧几里得算法\nAcWing 878. 线性同余方程\n\n中国剩余定理\nAcWing 204. 表达整数的奇怪方式\n\n高斯消元\nAcWing 883. 高斯消元解线性方程组\n\nAcWing 884. 高斯消元解异或线性方程组\n\n\n组合计数\nAcWing 885. 求组合数 I 3301人打卡\n\nAcWing 886. 求组合数 II 2874人打卡\n\nAcWing 887. 求组合数 III 2505人打卡\n\nAcWing 888. 求组合数 IV 2131人打卡\n\nAcWing 889. 满足条件的01序列\n\n\n容斥原理\nAcWing 890. 能被整除的数\n\n简单博弈论\nAcWing 891. Nim游戏 2857人打卡\n\nAcWing 892. 台阶-Nim游戏 2264人打卡\n\nAcWing 893. 集合-Nim游戏 2214人打卡\n\nAcWing 894. 拆分-Nim游戏\n\n\n","categories":["算法与数据结构"],"tags":["acwing","算法模板题"]},{"title":"acwing基础算法(5)：动态规划","url":"/2022/02/22/algorithm/acwing/%E5%9F%BA%E7%A1%80%E8%AF%BE/L5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"背包问题\nAcWing 2. 01背包问题\n\n二维数组#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int f[N][N];int main(){    int n, m;    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];        for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= m; j ++)        {            f[i][j] = f[i - 1][j];            if (j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);        }    cout &lt;&lt; f[n][m] &lt;&lt; endl;        return 0;}\n一维数组优化\nAcWing 3. 完全背包问题\n\nAcWing 4. 多重背包问题\n\nAcWing 5. 多重背包问题 II \n\nAcWing 9. 分组背包问题\n\n\n线性DP\nAcWing 898. 数字三角形\n\nAcWing 895. 最长上升子序列\n\nAcWing 896. 最长上升子序列 II\n\nAcWing 897. 最长公共子序列\n\nAcWing 902. 最短编辑距离\n\nAcWing 899. 编辑距离\n\n\n区间DP\nAcWing 282. 石子合并\n\n计数类DP\nAcWing 900. 整数划分\n\n数位统计DP\nAcWing 338. 计数问题\n\n状态压缩DP\nAcWing 291. 蒙德里安的梦想\n\nAcWing 91. 最短Hamilton路径\n\n\n树形DP\nAcWing 285. 没有上司的舞会\n\n记忆化搜索\nAcWing 901. 滑雪\n\n","categories":["算法与数据结构"],"tags":["acwing","算法模板题","dp"]},{"title":"acwing基础算法(6)：贪心","url":"/2022/02/22/algorithm/acwing/%E5%9F%BA%E7%A1%80%E8%AF%BE/L6-%E8%B4%AA%E5%BF%83/","content":"区间问题\nAcWing 905. 区间选点\n\nAcWing 908. 最大不相交区间数量\n\nAcWing 906. 区间分组\n\nAcWing 907. 区间覆盖\n\n\nHuffman树\nAcWing 148. 合并果子\n\n排序不等式\nAcWing 913. 排队打水\n\n绝对值不等式\nAcWing 104. 货仓选址\n\n推公式\nAcWing 125. 耍杂技的牛\n\n","categories":["算法与数据结构"],"tags":["acwing","算法模板题"]},{"title":"基础算法模板(2):数据结构","url":"/2022/02/18/algorithm/acwing/%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%A8%A1%E6%9D%BF2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"数据结构单链表 —— 模板题 AcWing 826. 单链表\n// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;// 初始化void init(){    head = -1;    idx = 0;}// 在链表头插入一个数avoid insert(int a){    e[idx] = a, ne[idx] = head, head = idx ++ ;}// 将头结点删除，需要保证头结点存在void remove(){    head = ne[head];}\n双链表 —— 模板题 AcWing 827. 双链表\n// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;// 初始化void init(){    //0是左端点，1是右端点    r[0] = 1, l[1] = 0;    idx = 2;}// 在节点a的右边插入一个数xvoid insert(int a, int x){    e[idx] = x;    l[idx] = a, r[idx] = r[a];    l[r[a]] = idx, r[a] = idx ++ ;}// 删除节点avoid remove(int a){    l[r[a]] = l[a];    r[l[a]] = r[a];}\n栈 —— 模板题 AcWing 828. 模拟栈\n// tt表示栈顶int stk[N], tt = 0;// 向栈顶插入一个数stk[ ++ tt] = x;// 从栈顶弹出一个数tt -- ;// 栈顶的值stk[tt];// 判断栈是否为空if (tt &gt; 0){}\n队列 —— 模板题 AcWing 829. 模拟队列\n\n普通队列\n\n// hh 表示队头，tt表示队尾int q[N], hh = 0, tt = -1;// 向队尾插入一个数q[ ++ tt] = x;// 从队头弹出一个数hh ++ ;// 队头的值q[hh];// 判断队列是否为空if (hh &lt;= tt){}\n\n循环队列\n\n// hh 表示队头，tt表示队尾的后一个位置int q[N], hh = 0, tt = 0;// 向队尾插入一个数q[tt ++ ] = x;if (tt == N) tt = 0;// 从队头弹出一个数hh ++ ;if (hh == N) hh = 0;// 队头的值q[hh];// 判断队列是否为空if (hh != tt){}\n单调栈 —— 模板题 AcWing 830. 单调栈\n常见模型：找出每个数左边离它最近的比它大/小的数int tt = 0;for (int i = 1; i &lt;= n; i ++ ){    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;    stk[ ++ tt] = i;}\n单调队列 —— 模板题 AcWing 154. 滑动窗口\n常见模型：找出滑动窗口中的最大值/最小值int hh = 0, tt = -1;for (int i = 0; i &lt; n; i ++ ){    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt -- ;    q[ ++ tt] = i;}\nKMP —— 模板题 AcWing 831. KMP字符串\n// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i = 2, j = 0; i &lt;= m; i ++ ){    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];    if (p[i] == p[j + 1]) j ++ ;    ne[i] = j;}// 匹配for (int i = 1, j = 0; i &lt;= n; i ++ ){    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];    if (s[i] == p[j + 1]) j ++ ;    if (j == m)    {        j = ne[j];        // 匹配成功后的逻辑    }}\nTrie树 —— 模板题 AcWing 835. Trie字符串统计\nint son[N][26], cnt[N], idx;// 0号点既是根节点，又是空节点// son[][]存储树中每个节点的子节点// cnt[]存储以每个节点结尾的单词数量// 插入一个字符串void insert(char *str){    int p = 0;    for (int i = 0; str[i]; i ++ )    {        int u = str[i] - 'a';        if (!son[p][u]) son[p][u] = ++ idx;        p = son[p][u];    }    cnt[p] ++ ;}// 查询字符串出现的次数int query(char *str){    int p = 0;    for (int i = 0; str[i]; i ++ )    {        int u = str[i] - 'a';        if (!son[p][u]) return 0;        p = son[p][u];    }    return cnt[p];}\n并查集 —— 模板题 AcWing 836. 合并集合, AcWing 837. 连通块中点的数量\n(1)朴素并查集：    int p[N]; //存储每个点的祖宗节点    // 返回x的祖宗节点    int find(int x)    {        if (p[x] != x) p[x] = find(p[x]);        return p[x];    }    // 初始化，假定节点编号是1~n    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 合并a和b所在的两个集合：    p[find(a)] = find(b);(2)维护size的并查集：    int p[N], size[N];    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量    // 返回x的祖宗节点    int find(int x)    {        if (p[x] != x) p[x] = find(p[x]);        return p[x];    }    // 初始化，假定节点编号是1~n    for (int i = 1; i &lt;= n; i ++ )    {        p[i] = i;        size[i] = 1;    }    // 合并a和b所在的两个集合：    size[find(b)] += size[find(a)];    p[find(a)] = find(b);(3)维护到祖宗节点距离的并查集：    int p[N], d[N];    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离    // 返回x的祖宗节点    int find(int x)    {        if (p[x] != x)        {            int u = find(p[x]);            d[x] += d[p[x]];            p[x] = u;        }        return p[x];    }    // 初始化，假定节点编号是1~n    for (int i = 1; i &lt;= n; i ++ )    {        p[i] = i;        d[i] = 0;    }    // 合并a和b所在的两个集合：    p[find(a)] = find(b);    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\n堆 —— 模板题 AcWing 838. 堆排序, AcWing 839. 模拟堆\n// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1// ph[k]存储第k个插入的点在堆中的位置// hp[k]存储堆中下标是k的点是第几个插入的int h[N], ph[N], hp[N], size;// 交换两个点，及其映射关系void heap_swap(int a, int b){    swap(ph[hp[a]],ph[hp[b]]);    swap(hp[a], hp[b]);    swap(h[a], h[b]);}void down(int u){    int t = u;    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;    if (u != t)    {        heap_swap(u, t);        down(t);    }}void up(int u){    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])    {        heap_swap(u, u / 2);        u &gt;&gt;= 1;    }}// O(n)建堆for (int i = n / 2; i; i -- ) down(i);\n一般哈希 —— 模板题 AcWing 840. 模拟散列表\n(1) 拉链法    int h[N], e[N], ne[N], idx;    // 向哈希表中插入一个数    void insert(int x)    {        int k = (x % N + N) % N;        e[idx] = x;        ne[idx] = h[k];        h[k] = idx ++ ;    }    // 在哈希表中查询某个数是否存在    bool find(int x)    {        int k = (x % N + N) % N;        for (int i = h[k]; i != -1; i = ne[i])            if (e[i] == x)                return true;        return false;    }(2) 开放寻址法    int h[N];    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置    int find(int x)    {        int t = (x % N + N) % N;        while (h[t] != null &amp;&amp; h[t] != x)        {            t ++ ;            if (t == N) t = 0;        }        return t;    }\n字符串哈希 —— 模板题 AcWing 841. 字符串哈希\n核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果typedef unsigned long long ULL;ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64// 初始化p[0] = 1;for (int i = 1; i &lt;= n; i ++ ){    h[i] = h[i - 1] * P + str[i];    p[i] = p[i - 1] * P;}// 计算子串 str[l ~ r] 的哈希值ULL get(int l, int r){    return h[r] - h[l - 1] * p[r - l + 1];}\nC++ STL简介\nvector, 变长数组，倍增的思想    size()  返回元素个数    empty()  返回是否为空    clear()  清空    front()/back()    push_back()/pop_back()    begin()/end()    []    支持比较运算，按字典序pair&lt;int, int&gt;    first, 第一个元素    second, 第二个元素    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）string，字符串    size()/length()  返回字符串长度    empty()    clear()    substr(起始下标，(子串长度))  返回子串    c_str()  返回字符串所在字符数组的起始地址queue, 队列    size()    empty()    push()  向队尾插入一个元素    front()  返回队头元素    back()  返回队尾元素    pop()  弹出队头元素priority_queue, 优先队列，默认是大根堆    size()    empty()    push()  插入一个元素    top()  返回堆顶元素    pop()  弹出堆顶元素    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;stack, 栈    size()    empty()    push()  向栈顶插入一个元素    top()  返回栈顶元素    pop()  弹出栈顶元素deque, 双端队列    size()    empty()    clear()    front()/back()    push_back()/pop_back()    push_front()/pop_front()    begin()/end()    []set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列    size()    empty()    clear()    begin()/end()    ++, -- 返回前驱和后继，时间复杂度 O(logn)    set/multiset        insert()  插入一个数        find()  查找一个数        count()  返回某一个数的个数        erase()            (1) 输入是一个数x，删除所有x   O(k + logn)            (2) 输入一个迭代器，删除这个迭代器        lower_bound()/upper_bound()            lower_bound(x)  返回大于等于x的最小的数的迭代器            upper_bound(x)  返回大于x的最小的数的迭代器    map/multimap        insert()  插入的数是一个pair        erase()  输入的参数是pair或者迭代器        find()        []  注意multimap不支持此操作。 时间复杂度是 O(logn)        lower_bound()/upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表    和上面类似，增删改查的时间复杂度是 O(1)    不支持 lower_bound()/upper_bound()， 迭代器的++，--bitset, 圧位    bitset&lt;10000&gt; s;    ~, &amp;, |, ^    &gt;&gt;, &lt;&lt;    ==, !=    []    count()  返回有多少个1    any()  判断是否至少有一个1    none()  判断是否全为0    set()  把所有位置成1    set(k, v)  将第k位变成v    reset()  把所有位变成0    flip()  等价于~    flip(k) 把第k位取反\n","categories":["算法与数据结构"],"tags":["acwing"]},{"title":"基础算法模板(1):基础算法","url":"/2022/02/18/algorithm/acwing/%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%A8%A1%E6%9D%BF1_%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/","content":"快速排序算法模板 —— 模板题 AcWing 785. 快速排序\nvoid quick_sort(int q[], int l, int r){    if (l &gt;= r) return;    int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1];    while (i &lt; j)    {        do i ++ ; while (q[i] &lt; x);        do j -- ; while (q[j] &gt; x);        if (i &lt; j) swap(q[i], q[j]);    }    quick_sort(q, l, j), quick_sort(q, j + 1, r);}\n归并排序算法模板 —— 模板题 AcWing 787. 归并排序\nvoid merge_sort(int q[], int l, int r){    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];}\n整数二分算法模板 —— 模板题 AcWing 789. 数的范围\nbool check(int x) {/* ... */} // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r){    while (l &lt; r)    {        int mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;    // check()判断mid是否满足性质        else l = mid + 1;    }    return l;}// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r){    while (l &lt; r)    {        int mid = l + r + 1 &gt;&gt; 1;        if (check(mid)) l = mid;        else r = mid - 1;    }    return l;}\n浮点数二分算法模板 —— 模板题 AcWing 790. 数的三次方根\nbool check(double x) {/* ... */} // 检查x是否满足某种性质double bsearch_3(double l, double r){    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求    while (r - l &gt; eps)    {        double mid = (l + r) / 2;        if (check(mid)) r = mid;        else l = mid;    }    return l;}\n高精度加法 —— 模板题 AcWing 791. 高精度加法\n// C = A + B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B){    if (A.size() &lt; B.size()) return add(B, A);    vector&lt;int&gt; C;    int t = 0;    for (int i = 0; i &lt; A.size(); i ++ )    {        t += A[i];        if (i &lt; B.size()) t += B[i];        C.push_back(t % 10);        t /= 10;    }    if (t) C.push_back(t);    return C;}\n高精度减法 —— 模板题 AcWing 792. 高精度减法\n// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B){    vector&lt;int&gt; C;    for (int i = 0, t = 0; i &lt; A.size(); i ++ )    {        t = A[i] - t;        if (i &lt; B.size()) t -= B[i];        C.push_back((t + 10) % 10);        if (t &lt; 0) t = 1;        else t = 0;    }    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;}\n高精度乘低精度 —— 模板题 AcWing 793. 高精度乘法\n// C = A * b, A &gt;= 0, b &gt;= 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b){    vector&lt;int&gt; C;    int t = 0;    for (int i = 0; i &lt; A.size() || t; i ++ )    {        if (i &lt; A.size()) t += A[i] * b;        C.push_back(t % 10);        t /= 10;    }    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;}\n高精度除以低精度 —— 模板题 AcWing 794. 高精度除法\n// A / b = C ... r, A &gt;= 0, b &gt; 0vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r){    vector&lt;int&gt; C;    r = 0;    for (int i = A.size() - 1; i &gt;= 0; i -- )    {        r = r * 10 + A[i];        C.push_back(r / b);        r %= b;    }    reverse(C.begin(), C.end());    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;}\n一维前缀和 —— 模板题 AcWing 795. 前缀和\nS[i] = a[1] + a[2] + ... a[i]a[l] + ... + a[r] = S[r] - S[l - 1]\n二维前缀和 —— 模板题 AcWing 796. 子矩阵的和\nS[i, j] = 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]\n一维差分 —— 模板题 AcWing 797. 差分\n给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c\n二维差分 —— 模板题 AcWing 798. 差分矩阵\n给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c\n位运算 —— 模板题 AcWing 801. 二进制中1的个数\n求n的第k位数字: n &gt;&gt; k &amp; 1返回n的最后一位1：lowbit(n) = n &amp; -n\n双指针算法 —— 模板题 AcWIng 799. 最长连续不重复子序列, AcWing 800. 数组元素的目标和\nfor (int i = 0, j = 0; i &lt; n; i ++ ){    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;    // 具体问题的逻辑}常见问题分类：    (1) 对于一个序列，用两个指针维护一段区间    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\n离散化 —— 模板题 AcWing 802. 区间和\nvector&lt;int&gt; alls; // 存储所有待离散化的值sort(alls.begin(), alls.end()); // 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素// 二分求出x对应的离散化的值int find(int x) // 找到第一个大于等于x的位置{    int l = 0, r = alls.size() - 1;    while (l &lt; r)    {        int mid = l + r &gt;&gt; 1;        if (alls[mid] &gt;= x) r = mid;        else l = mid + 1;    }    return r + 1; // 映射到1, 2, ...n}\n区间合并 —— 模板题 AcWing 803. 区间合并\n// 将所有存在交集的区间合并void merge(vector&lt;PII&gt; &amp;segs){    vector&lt;PII&gt; res;    sort(segs.begin(), segs.end());    int st = -2e9, ed = -2e9;    for (auto seg : segs)        if (ed &lt; seg.first)        {            if (st != -2e9) res.push_back({st, ed});            st = seg.first, ed = seg.second;        }        else ed = max(ed, seg.second);    if (st != -2e9) res.push_back({st, ed});    segs = res;}\n","categories":["算法与数据结构"],"tags":["acwing"]},{"title":"基础算法模板(3):搜索与图论","url":"/2022/02/18/algorithm/acwing/%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%A8%A1%E6%9D%BF3_%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/","content":"树与图的存储\n树是一种特殊的图，与图的存储方式相同。\n对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。\n因此我们可以只考虑有向图的存储。\n1) 邻接矩阵：g[a][b] 存储边a-&gt;b2) 邻接表\n// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点int h[N], e[N], ne[N], idx;// 添加一条边a-&gt;bvoid add(int a, int b)&#123;    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;&#125;// 初始化idx = 0;memset(h, -1, sizeof h);\n树与图的遍历\n时间复杂度 $O(n+m)$, n 表示点数，m 表示边数\n(1)深度优先遍历 —— 模板题 AcWing 846. 树的重心\nint dfs(int u)&#123;    st[u] = true; // st[u] 表示点u已经被遍历过    for (int i = h[u]; i != -1; i = ne[i])    &#123;        int j = e[i];        if (!st[j]) dfs(j);    &#125;&#125;\n(2) 宽度优先遍历 —— 模板题 AcWing 847. 图中点的层次\nqueue&lt;int&gt; q;st[1] = true; // 表示1号点已经被遍历过q.push(1);while (q.size())&#123;    int t = q.front();    q.pop();    for (int i = h[t]; i != -1; i = ne[i])    &#123;        int j = e[i];        if (!st[j])        &#123;            st[j] = true; // 表示点j已经被遍历过            q.push(j);        &#125;    &#125;&#125;\n拓扑排序 —— 模板题 AcWing 848. 有向图的拓扑序列\n时间复杂度 $O(n+m)$, n 表示点数，m 表示边数\nbool topsort()&#123;    int hh = 0, tt = -1;    // d[i] 存储点i的入度    for (int i = 1; i &lt;= n; i ++ )        if (!d[i])            q[ ++ tt] = i;    while (hh &lt;= tt)    &#123;        int t = q[hh ++ ];        for (int i = h[t]; i != -1; i = ne[i])        &#123;            int j = e[i];            if (-- d[j] == 0)                q[ ++ tt] = j;        &#125;    &#125;    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。    return tt == n - 1;&#125;\n朴素dijkstra算法 —— 模板题 AcWing 849. Dijkstra求最短路 I\n时间复杂是$O(n^2+m)$, n 表示点数，m 表示边数\nint g[N][N];  // 存储每条边int dist[N];  // 存储1号点到每个点的最短距离bool st[N];   // 存储每个点的最短路是否已经确定// 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for (int i = 0; i &lt; n - 1; i ++ )    &#123;        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        // 用t更新其他点的距离        for (int j = 1; j &lt;= n; j ++ )            dist[j] = min(dist[j], dist[t] + g[t][j]);        st[t] = true;    &#125;    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];&#125;\n堆优化版dijkstra —— 模板题 AcWing 850. Dijkstra求最短路 II\n时间复杂度 $O(mlogn)$, n 表示点数，m 表示边数\ntypedef pair&lt;int, int&gt; PII;int n;      // 点的数量int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        // 存储所有点到1号点的距离bool st[N];     // 存储每个点的最短距离是否已确定// 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push(&#123;0, 1&#125;);      // first存储距离，second存储节点编号    while (heap.size())    &#123;        auto t = heap.top();        heap.pop();        int ver = t.second, distance = t.first;        if (st[ver]) continue;        st[ver] = true;        for (int i = h[ver]; i != -1; i = ne[i])        &#123;            int j = e[i];            if (dist[j] &gt; distance + w[i])            &#123;                dist[j] = distance + w[i];                heap.push(&#123;dist[j], j&#125;);            &#125;        &#125;    &#125;    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];&#125;\nBellman-Ford算法 —— 模板题 AcWing 853. 有边数限制的最短路\n时间复杂度 $O(nm)$, n 表示点数，m 表示边数\n注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。\nint n, m;       // n表示点数，m表示边数int dist[N];        // dist[x]存储1到x的最短路距离struct Edge     // 边，a表示出点，b表示入点，w表示边的权重&#123;    int a, b, w;&#125;edges[M];// 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。    for (int i = 0; i &lt; n; i ++ )    &#123;        for (int j = 0; j &lt; m; j ++ )        &#123;            int a = edges[j].a, b = edges[j].b, w = edges[j].w;            if (dist[b] &gt; dist[a] + w)                dist[b] = dist[a] + w;        &#125;    &#125;    if (dist[n] &gt; 0x3f3f3f3f / 2) return -1;    return dist[n];&#125;\nspfa 算法（队列优化的Bellman-Ford算法） —— 模板题 AcWing 851. spfa求最短路\n时间复杂度 平均情况下 $O(m)$，最坏情况下 $O(nm)$, n 表示点数，m 表示边数\nint n;      // 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N];        // 存储每个点到1号点的最短距离bool st[N];     // 存储每个点是否在队列中// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    queue&lt;int&gt; q;    q.push(1);    st[1] = true;    while (q.size())    &#123;        auto t = q.front();        q.pop();        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        &#123;            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] = dist[t] + w[i];                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入                &#123;                    q.push(j);                    st[j] = true;                &#125;            &#125;        &#125;    &#125;    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];&#125;\nspfa判断图中是否存在负环 —— 模板题 AcWing 852. spfa判断负环\n时间复杂度是 $O(nm)$, n 表示点数，m 表示边数\nint n;      // 总点数int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数bool st[N];     // 存储每个点是否在队列中// 如果存在负环，则返回true，否则返回false。bool spfa()&#123;    // 不需要初始化dist数组    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。    queue&lt;int&gt; q;    for (int i = 1; i &lt;= n; i ++ )    &#123;        q.push(i);        st[i] = true;    &#125;    while (q.size())    &#123;        auto t = q.front();        q.pop();        st[t] = false;        for (int i = h[t]; i != -1; i = ne[i])        &#123;            int j = e[i];            if (dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] = dist[t] + w[i];                cnt[j] = cnt[t] + 1;                if (cnt[j] &gt;= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环                if (!st[j])                &#123;                    q.push(j);                    st[j] = true;                &#125;            &#125;        &#125;    &#125;    return false;&#125;\nfloyd算法 —— 模板题 AcWing 854. Floyd求最短路\n时间复杂度是 $O(n^3)$, n 表示点数\n初始化：    for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ )            if (i == j) d[i][j] = 0;            else d[i][j] = INF;// 算法结束后，d[a][b]表示a到b的最短距离void floyd()&#123;    for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++ )            for (int j = 1; j &lt;= n; j ++ )                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);&#125;\n朴素版prim算法 —— 模板题 AcWing 858. Prim算法求最小生成树\n时间复杂度是 $O(n^2+m)$, n 表示点数，m 表示边数\nint n;      // n表示点数int g[N][N];        // 邻接矩阵，存储所有边int dist[N];        // 存储其他点到当前最小生成树的距离bool st[N];     // 存储每个点是否已经在生成树中// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和int prim()&#123;    memset(dist, 0x3f, sizeof dist);    int res = 0;    for (int i = 0; i &lt; n; i ++ )    &#123;        int t = -1;        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        if (i &amp;&amp; dist[t] == INF) return INF;        if (i) res += dist[t];        st[t] = true;        for (int j = 1; j &lt;= n; j ++ ) dist[j] = min(dist[j], g[t][j]);    &#125;    return res;&#125;\nKruskal算法 —— 模板题 AcWing 859. Kruskal算法求最小生成树\n时间复杂度是 $O(mlogm)$, n 表示点数，m 表示边数int n, m;       // n是点数，m是边数int p[N];       // 并查集的父节点数组struct Edge     // 存储边&#123;    int a, b, w;    bool operator&lt; (const Edge &amp;W)const    &#123;        return w &lt; W.w;    &#125;&#125;edges[M];int find(int x)     // 并查集核心操作&#123;    if (p[x] != x) p[x] = find(p[x]);    return p[x];&#125;int kruskal()&#123;    sort(edges, edges + m);    for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // 初始化并查集        int res = 0, cnt = 0;    for (int i = 0; i &lt; m; i ++ )    &#123;        int a = edges[i].a, b = edges[i].b, w = edges[i].w;            a = find(a), b = find(b);        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并        &#123;            p[a] = b;            res += w;            cnt ++ ;        &#125;    &#125;        if (cnt &lt; n - 1) return INF;    return res;    &#125;\n染色法判别二分图 —— 模板题 AcWing 860. 染色法判定二分图时间复杂度是 $O(n+m)$, n 表示点数，m 表示边数\nint n;      // n表示点数int h[N], e[M], ne[M], idx;     // 邻接表存储图int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色// 参数：u表示当前节点，c表示当前点的颜色bool dfs(int u, int c)&#123;    color[u] = c;    for (int i = h[u]; i != -1; i = ne[i])    &#123;        int j = e[i];        if (color[j] == -1)        &#123;            if (!dfs(j, !c)) return false;        &#125;        else if (color[j] == c) return false;    &#125;    return true;&#125;bool check()&#123;    memset(color, -1, sizeof color);    bool flag = true;    for (int i = 1; i &lt;= n; i ++ )        if (color[i] == -1)            if (!dfs(i, 0))            &#123;                flag = false;                break;            &#125;    return flag;&#125;\n匈牙利算法 —— 模板题 AcWing 861. 二分图的最大匹配\n时间复杂度是 O(nm), n 表示点数，m 表示边数int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过bool find(int x)&#123;    for (int i = h[x]; i != -1; i = ne[i])    &#123;        int j = e[i];        if (!st[j])        &#123;            st[j] = true;            if (match[j] == 0 || find(match[j]))            &#123;                match[j] = x;                return true;            &#125;        &#125;    &#125;    return false;&#125;// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点int res = 0;for (int i = 1; i &lt;= n1; i ++ )&#123;    memset(st, false, sizeof st);    if (find(i)) res ++ ;&#125;\n","categories":["算法与数据结构"],"tags":["acwing"]},{"title":"基础算法模板(4):数学知识","url":"/2022/02/18/algorithm/acwing/%E5%9F%BA%E7%A1%80%E8%AF%BE/%E6%A8%A1%E6%9D%BF4_%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/","content":"试除法判定质数 —— 模板题 AcWing 866. 试除法判定质数bool is_prime(int x)&#123;    if (x &lt; 2) return false;    for (int i = 2; i &lt;= x / i; i ++ )        if (x % i == 0)            return false;    return true;&#125;\n试除法分解质因数 —— 模板题 AcWing 867. 分解质因数void divide(int x)&#123;    for (int i = 2; i &lt;= x / i; i ++ )        if (x % i == 0)        &#123;            int s = 0;            while (x % i == 0) x /= i, s ++ ;            cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; s &lt;&lt; endl;        &#125;    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; 1 &lt;&lt; endl;    cout &lt;&lt; endl;&#125;\n朴素筛法求素数 —— 模板题 AcWing 868. 筛质数int primes[N], cnt;     // primes[]存储所有素数bool st[N];         // st[x]存储x是否被筛掉void get_primes(int n)&#123;    for (int i = 2; i &lt;= n; i ++ )    &#123;        if (st[i]) continue;        primes[cnt ++ ] = i;        for (int j = i + i; j &lt;= n; j += i)            st[j] = true;    &#125;&#125;\n线性筛法求素数 —— 模板题 AcWing 868. 筛质数int primes[N], cnt;     // primes[]存储所有素数bool st[N];         // st[x]存储x是否被筛掉void get_primes(int n)&#123;    for (int i = 2; i &lt;= n; i ++ )    &#123;        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        &#123;            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        &#125;    &#125;&#125;\n试除法求所有约数 —— 模板题 AcWing 869. 试除法求约数vector&lt;int&gt; get_divisors(int x)&#123;    vector&lt;int&gt; res;    for (int i = 1; i &lt;= x / i; i ++ )        if (x % i == 0)        &#123;            res.push_back(i);            if (i != x / i) res.push_back(x / i);        &#125;    sort(res.begin(), res.end());    return res;&#125;约数个数和约数之和 —— 模板题 AcWing 870. 约数个数, AcWing 871. 约数之和如果 N = p1^c1 * p2^c2 * ... *pk^ck约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)欧几里得算法 —— 模板题 AcWing 872. 最大公约数int gcd(int a, int b)&#123;    return b ? gcd(b, a % b) : a;&#125;求欧拉函数 —— 模板题 AcWing 873. 欧拉函数int phi(int x)&#123;    int res = x;    for (int i = 2; i &lt;= x / i; i ++ )        if (x % i == 0)        &#123;            res = res / i * (i - 1);            while (x % i == 0) x /= i;        &#125;    if (x &gt; 1) res = res / x * (x - 1);    return res;&#125;筛法求欧拉函数 —— 模板题 AcWing 874. 筛法求欧拉函数int primes[N], cnt;     // primes[]存储所有素数int euler[N];           // 存储每个数的欧拉函数bool st[N];         // st[x]存储x是否被筛掉void get_eulers(int n)&#123;    euler[1] = 1;    for (int i = 2; i &lt;= n; i ++ )    &#123;        if (!st[i])        &#123;            primes[cnt ++ ] = i;            euler[i] = i - 1;        &#125;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        &#123;            int t = primes[j] * i;            st[t] = true;            if (i % primes[j] == 0)            &#123;                euler[t] = euler[i] * primes[j];                break;            &#125;            euler[t] = euler[i] * (primes[j] - 1);        &#125;    &#125;&#125;快速幂 —— 模板题 AcWing 875. 快速幂求 m^k mod p，时间复杂度 O(logk)。int qmi(int m, int k, int p)&#123;    int res = 1 % p, t = m;    while (k)    &#123;        if (k&amp;1) res = res * t % p;        t = t * t % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;扩展欧几里得算法 —— 模板题 AcWing 877. 扩展欧几里得算法// 求x, y，使得ax + by = gcd(a, b)int exgcd(int a, int b, int &amp;x, int &amp;y)&#123;    if (!b)    &#123;        x = 1; y = 0;        return a;    &#125;    int d = exgcd(b, a % b, y, x);    y -= (a/b) * x;    return d;&#125;高斯消元 —— 模板题 AcWing 883. 高斯消元解线性方程组// a[N][N]是增广矩阵int gauss()&#123;    int c, r;    for (c = 0, r = 0; c &lt; n; c ++ )    &#123;        int t = r;        for (int i = r; i &lt; n; i ++ )   // 找到绝对值最大的行            if (fabs(a[i][c]) &gt; fabs(a[t][c]))                t = i;        if (fabs(a[t][c]) &lt; eps) continue;            for (int i = c; i &lt;= n; i ++ ) swap(a[t][i], a[r][i]);      // 将绝对值最大的行换到最顶端        for (int i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      // 将当前行的首位变成1        for (int i = r + 1; i &lt; n; i ++ )       // 用当前行将下面所有的列消成0            if (fabs(a[i][c]) &gt; eps)                for (int j = n; j &gt;= c; j -- )                    a[i][j] -= a[r][j] * a[i][c];            r ++ ;    &#125;        if (r &lt; n)    &#123;        for (int i = r; i &lt; n; i ++ )            if (fabs(a[i][n]) &gt; eps)                return 2; // 无解        return 1; // 有无穷多组解    &#125;        for (int i = n - 1; i &gt;= 0; i -- )        for (int j = i + 1; j &lt; n; j ++ )            a[i][n] -= a[i][j] * a[j][n];        return 0; // 有唯一解&#125;递归法求组合数 —— 模板题 AcWing 885. 求组合数 // c[a][b] 表示从a个苹果中选b个的方案数for (int i = 0; i &lt; N; i ++ )    for (int j = 0; j &lt;= i; j ++ )        if (!j) c[i][j] = 1;        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n通过预处理逆元的方式求组合数 —— 模板题 AcWing 886. 求组合数 II首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]如果取模的数是质数，可以用费马小定理求逆元int qmi(int a, int k, int p)    // 快速幂模板&#123;    int res = 1;    while (k)    &#123;        if (k &amp; 1) res = (LL)res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;// 预处理阶乘的余数和阶乘逆元的余数fact[0] = infact[0] = 1;for (int i = 1; i &lt; N; i ++ )&#123;    fact[i] = (LL)fact[i - 1] * i % mod;    infact[i] = (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;&#125;Lucas定理 —— 模板题 AcWing 887. 求组合数 III若p是质数，则对于任意整数 1 &lt;= m &lt;= n，有：    C(n, m) = C(n % p, m % p) * C(n / p, m / p) (mod p)int qmi(int a, int k, int p)  // 快速幂模板&#123;    int res = 1 % p;    while (k)    &#123;        if (k &amp; 1) res = (LL)res * a % p;        a = (LL)a * a % p;        k &gt;&gt;= 1;    &#125;    return res;&#125;int C(int a, int b, int p)  // 通过定理求组合数C(a, b)&#123;    if (a &lt; b) return 0;    LL x = 1, y = 1;  // x是分子，y是分母    for (int i = a, j = 1; j &lt;= b; i --, j ++ )    &#123;        x = (LL)x * i % p;        y = (LL) y * j % p;    &#125;        return x * (LL)qmi(y, p - 2, p) % p;&#125;int lucas(LL a, LL b, int p)&#123;    if (a &lt; p &amp;&amp; b &lt; p) return C(a, b, p);    return (LL)C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;&#125;分解质因数法求组合数 —— 模板题 AcWing 888. 求组合数 IV当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：    1. 筛法求出范围内的所有质数    2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + ...    3. 用高精度乘法将所有质因子相乘int primes[N], cnt;     // 存储所有质数int sum[N];     // 存储每个质数的次数bool st[N];     // 存储每个数是否已被筛掉void get_primes(int n)      // 线性筛法求素数&#123;    for (int i = 2; i &lt;= n; i ++ )    &#123;        if (!st[i]) primes[cnt ++ ] = i;        for (int j = 0; primes[j] &lt;= n / i; j ++ )        &#123;            st[primes[j] * i] = true;            if (i % primes[j] == 0) break;        &#125;    &#125;&#125;int get(int n, int p)       // 求n！中的次数&#123;    int res = 0;    while (n)    &#123;        res += n / p;        n /= p;    &#125;    return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)       // 高精度乘低精度模板&#123;    vector&lt;int&gt; c;    int t = 0;    for (int i = 0; i &lt; a.size(); i ++ )    &#123;        t += a[i] * b;        c.push_back(t % 10);        t /= 10;    &#125;    while (t)    &#123;        c.push_back(t % 10);        t /= 10;    &#125;        return c;&#125;get_primes(a);  // 预处理范围内的所有质数for (int i = 0; i &lt; cnt; i ++ )     // 求每个质因数的次数&#123;    int p = primes[i];    sum[i] = get(a, p) - get(b, p) - get(a - b, p);&#125;vector&lt;int&gt; res;res.push_back(1);for (int i = 0; i &lt; cnt; i ++ )     // 用高精度乘法将所有质因子相乘    for (int j = 0; j &lt; sum[i]; j ++ )        res = mul(res, primes[i]);卡特兰数 —— 模板题 AcWing 889. 满足条件的01序列给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) = C(2n, n) / (n + 1)NIM游戏 —— 模板题 AcWing 891. Nim游戏给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。NIM博弈不存在平局，只有先手必胜和先手必败两种情况。定理： NIM博弈先手必胜，当且仅当 A1 ^ A2 ^ … ^ An != 0公平组合游戏ICG若一个游戏满足：由两名玩家交替行动；在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；不能行动的玩家判负；则称该游戏为一个公平组合游戏。NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。有向图游戏给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。Mex运算设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：mex(S) = min&#123;x&#125;, x属于自然数，且x不属于SSG函数在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：SG(x) = mex(&#123;SG(y1), SG(y2), …, SG(yk)&#125;)特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)定理有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。\n","categories":["算法与数据结构"],"tags":["acwing"]},{"title":"2014级软件学院算法分析与设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2014%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/C1-2014%E7%BA%A7%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"/*  Author: 武迪 Result: AC\tSubmission_id: 4095274 Created at: Fri Jan 07 2022 23:40:56 GMT+0800 (China Standard Time) Problem_id: 14\tTime: 124\tMemory: 4200*/#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010;int q[N], tmp[N], n;unsigned long res = 0;void merge_sort(int q[], int l, int r)&#123;    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)&#123;        if(q[i] &lt;= q[j]) tmp[k++] = q[i++];        else&#123;            tmp[k++] = q[j++];            res += mid - i + 1;        &#125;    &#125;    while (i &lt;= mid) tmp[k++] = q[i++];    while (j &lt;= r) tmp[k++] = q[j++];    for(i=l, j=0;i&lt;=r;i++,j++) q[i] = tmp[j];&#125;int main()&#123;    while (scanf(&quot;%d&quot;, &amp;n) != EOF)    &#123;        for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]);        res = 0;        merge_sort(q, 0, n - 1);        cout &lt;&lt; res &lt;&lt; endl;    &#125;  return 0;  &#125;\n","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2014级软件学院算法分析与设计 - 第二次上机","url":"/2022/02/20/algorithm/oj4th/2014%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/C2-2014%E7%BA%A7%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2014级软件学院算法分析与设计 - 第四次上机","url":"/2022/02/20/algorithm/oj4th/2014%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/C4-2014%E7%BA%A7%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2014级软件学院算法分析与设计 - 第三次上机","url":"/2022/02/20/algorithm/oj4th/2014%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/C3-2014%E7%BA%A7%E7%AE%97%E6%B3%95%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2014级软件学院算法分析与设计 - 第五次上机","url":"/2022/02/20/algorithm/oj4th/2014%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/C5-2014%E7%BA%A7%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%94%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2014级软件学院算法分析与设计 - 第六次上机","url":"/2022/02/20/algorithm/oj4th/2014%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/C6-2014%E7%BA%A7%E7%AE%97%E6%B3%95%E7%AC%AC%E5%85%AD%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2014级软件学院算法分析与设计-算法练习赛","url":"/2022/02/20/algorithm/oj4th/2014%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%E8%B5%9B/","content":"/*  Author: 武迪 Result: AC\tSubmission_id: 4095286 Created at: Sat Jan 08 2022 01:02:04 GMT+0800 (China Standard Time) Problem_id: 39\tTime: 10\tMemory: 3424*/#include &lt;iostream&gt;using namespace std;const int N = 250010;int a[N];int main()&#123;    int n, m;    while (cin &gt;&gt; n &gt;&gt; m)    &#123;        for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);        while (m -- )        &#123;            int x;            cin &gt;&gt; x;            int l = 0, r = n - 1;            while (l &lt; r)            &#123;                int mid = l + r &gt;&gt; 1;                if(a[mid] &gt;= x) r = mid;                else l = mid + 1;            &#125;            if (a[l] != x) cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;            else cout &lt;&lt; l + 1 &lt;&lt; endl;        &#125;    &#125;        return 0;&#125;\n","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/C1-2015%E7%BA%A7C++%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"/*  Author: 武迪 Result: AC\tSubmission_id: 4095276 Created at: Fri Jan 07 2022 23:47:56 GMT+0800 (China Standard Time) Problem_id: 18\tTime: 20\tMemory: 3528*/#include &lt;iostream&gt;using namespace std;int main()&#123;    double a, b, c;    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;    printf(&quot;%.2f&quot;, (a + b + c) / 3);    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095277 Created at: Fri Jan 07 2022 23:51:47 GMT+0800 (China Standard Time) Problem_id: 19\tTime: 5\tMemory: 3432*/#include &lt;iostream&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    int res = n % 3? n / 3 + 1 :n / 3;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095279 Created at: Sat Jan 08 2022 00:05:38 GMT+0800 (China Standard Time) Problem_id: 20\tTime: 28\tMemory: 3308*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    long long a, b;    cin &gt;&gt; a &gt;&gt; b;    cout &lt;&lt; a + b &lt;&lt; endl;    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095280 Created at: Sat Jan 08 2022 00:11:36 GMT+0800 (China Standard Time) Problem_id: 21\tTime: 1\tMemory: 3444*/#include &lt;iostream&gt;using namespace std;int main()&#123;    double n;    while (cin &gt;&gt; n)&#123;        if (n &gt;= 90 &amp;&amp; n &lt;= 100) cout &lt;&lt; &#x27;A&#x27; &lt;&lt; endl;        else if (n &gt;= 80 &amp;&amp; n &lt; 90) cout &lt;&lt; &quot;B&quot; &lt;&lt; endl;        else if (n &gt;= 70 &amp;&amp; n &lt; 80) cout &lt;&lt; &quot;C&quot; &lt;&lt; endl;        else if (n &gt;= 60 &amp;&amp; n &lt; 70) cout &lt;&lt; &quot;D&quot; &lt;&lt; endl;        else if (n &gt;= 0 &amp;&amp; n &lt; 60) cout &lt;&lt; &quot;E&quot; &lt;&lt; endl;        else cout &lt;&lt; &quot;wrong&quot; &lt;&lt; endl;            &#125;    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095282 Created at: Sat Jan 08 2022 00:15:37 GMT+0800 (China Standard Time) Problem_id: 22\tTime: 4\tMemory: 3368*/#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;//\\\\\\\\^&#x27;\\\\n#s)\\\\tF*//\\\\r&quot; &lt;&lt; endl;    cout &lt;&lt; endl;    cout &lt;&lt; &quot;http://i.youku.com/microhhh&quot; &lt;&lt; endl;    return 0;&#125;\n","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/C2-2015%E7%BA%A7C++%E7%AC%AC%E4%BA%8C%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"/*  Author: 武迪 Result: AC\tSubmission_id: 4095316 Created at: Sat Jan 08 2022 13:18:56 GMT+0800 (China Standard Time) Problem_id: 32\tTime: 436\tMemory: 3432*/#include &lt;iostream&gt;using namespace std;int main()&#123;        int n, m;    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) !=EOF)    &#123;        if (n == m) cout &lt;&lt; n &lt;&lt; &#x27; &#x27; &lt;&lt; 0 &lt;&lt; endl;        else if (n &gt; m) cout &lt;&lt; m &lt;&lt; &#x27; &#x27; &lt;&lt; (n - m) / 2 &lt;&lt; endl;        else cout &lt;&lt; n &lt;&lt; &#x27; &#x27; &lt;&lt; (m - n) / 2 &lt;&lt; endl;    &#125;        return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095325 Created at: Sat Jan 08 2022 14:03:49 GMT+0800 (China Standard Time) Problem_id: 34\tTime: 4\tMemory: 3404*/#include &lt;iostream&gt;using namespace std;int main()&#123;    int a, b, c;    while (scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c) != EOF)    &#123;        if (a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a)&#123;            if (a * a + b * b == c * c || a * a + c * c == b * b || c * c + b * b == a * a) cout &lt;&lt; &quot;good&quot; &lt;&lt; endl;            else if (a == b || a == c || b == c) cout &lt;&lt; &quot;perfect&quot; &lt;&lt; endl;            else cout &lt;&lt; &quot;just a triangle&quot; &lt;&lt; endl;        &#125;else cout &lt;&lt; &quot;wrong&quot; &lt;&lt; endl;    &#125;    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095410 Created at: Sat Jan 08 2022 21:30:24 GMT+0800 (China Standard Time) Problem_id: 35\tTime: 42\tMemory: 3456*/#include &lt;iostream&gt;using namespace std;int main()&#123;    int n;    while (scanf(&quot;%d&quot;, &amp;n) != EOF)    &#123;           n += 2;        while (n % 3 == 0) n /= 3;        while (n % 5 == 0) n /= 5;        if (n == 1) printf(&quot;Yes\\n&quot;);        else printf(&quot;No\\n&quot;);    &#125;    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095329 Created at: Sat Jan 08 2022 14:12:25 GMT+0800 (China Standard Time) Problem_id: 36\tTime: 801\tMemory: 3600*/#include &lt;iostream&gt;using namespace std;int main()&#123;    int n, m, k;    while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)    &#123;        k = n / m;        printf(&quot;%d %d\\n&quot;, k, k * m);    &#125;    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095290 Created at: Sat Jan 08 2022 01:16:06 GMT+0800 (China Standard Time) Problem_id: 37\tTime: 4\tMemory: 3472*/#include &lt;iostream&gt;using namespace std;const double eps = 0.0000001;int main()&#123;    double n, m;    while (cin &gt;&gt; n &gt;&gt; m)    &#123;        if (n - m &gt;= eps) cout &lt;&lt; &quot;woshibukezhanshengde&quot;&lt;&lt; endl;        if (m - n &gt;= eps) cout &lt;&lt; &quot;wohenbaoqian&quot; &lt;&lt; endl;        if (n - m &lt; eps &amp;&amp; n - m &gt; -eps) cout &lt;&lt; &quot;nakezhenchun&quot; &lt;&lt; endl;    &#125;        return 0;&#125;\n","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/C3-2015%E7%BA%A7C++%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/C4-2015%E7%BA%A7C++%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/C5-2015%E7%BA%A7C++%E7%AC%AC%E4%BA%94%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/C6-2015%E7%BA%A7C++%E7%AC%AC%E5%85%AD%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/C7-2015%E7%BA%A7C++%E7%AC%AC%E4%B8%83%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/C8-2015%E7%BA%A7C++%E7%AC%AC%E5%85%AB%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/C9-2015%E7%BA%A7C++%E7%AC%AC%E4%B9%9D%E6%AC%A1%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/E1-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%AF%94%E8%B5%9B/","content":"/*  Author: 武迪 Result: AC\tSubmission_id: 4095073 Created at: Thu Jan 06 2022 15:27:50 GMT+0800 (China Standard Time) Problem_id: 2\tTime: 2\tMemory: 1540*/#include &lt;stdio.h&gt;int main()&#123;    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    printf(&quot;%d&quot;, n%m);    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095074 Created at: Thu Jan 06 2022 15:30:17 GMT+0800 (China Standard Time) Problem_id: 3\tTime: 2\tMemory: 1632*/#include&lt;stdio.h&gt;int main()&#123;    int n, m, k;    while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k)!=EOF)&#123;        int sum = n;        while (k)&#123;            int p = n + m * k;            sum += p;            k --;        &#125;        printf(&quot;%d\\n&quot;, sum);    &#125;    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095076 Created at: Thu Jan 06 2022 15:35:21 GMT+0800 (China Standard Time) Problem_id: 4\tTime: 2\tMemory: 1348*/#include&lt;stdio.h&gt;int main()&#123;        char s[] = &quot;\\&quot;\\\\a\\\\t\\\\0\\\\y\\\\a\\\\n\\\\g\\&quot;&quot;;    printf(&quot;%s&quot;, s);        return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095262 Created at: Fri Jan 07 2022 23:02:00 GMT+0800 (China Standard Time) Problem_id: 5\tTime: 222\tMemory: 20184*/#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int fun(int n)&#123;    int sum = 0;    while (n &gt; 0)&#123;        sum += n % 10;        n /= 10;    &#125;    if (sum &gt;= 10) return fun(sum);    else return sum;&#125;int main()&#123;    string s;    cin &gt;&gt; s;    int res = 0;    for (int i = 0; i &lt; s.size(); i ++ ) res += (s[i] - &#x27;0&#x27;);    cout &lt;&lt; fun(res) &lt;&lt; endl;    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095077 Created at: Thu Jan 06 2022 15:57:08 GMT+0800 (China Standard Time) Problem_id: 6\tTime: 3\tMemory: 3320*/#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10;int main()&#123;        string s;    while (cin &gt;&gt; s)&#123;        while (s.size() &gt; 1 &amp;&amp; s.back() == &#x27;0&#x27;) s.pop_back();        reverse(s.begin(), s.end());        cout &lt;&lt; s &lt;&lt; endl;    &#125;        return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095082 Created at: Thu Jan 06 2022 16:21:58 GMT+0800 (China Standard Time) Problem_id: 7\tTime: 2\tMemory: 3420*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;string print_shape(int n, int m)&#123;    string res;    int n1 = n, n2 = n;    while (n1 -- ) res += &quot; &quot;;    while (m -- ) res += &quot;#&quot;;    while (n2 -- ) res += &quot; &quot;;    return res; &#125;int main()&#123;    int n;    while (cin &gt;&gt; n)&#123;        int length = 2 * n - 1;        while (n)        &#123;            int sharps = 2 * n - 1;            int blocks = (length - sharps) / 2;            string s = print_shape(blocks, sharps);            cout &lt;&lt; s &lt;&lt; endl;            n -- ;        &#125;    &#125;    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095257 Created at: Fri Jan 07 2022 22:45:00 GMT+0800 (China Standard Time) Problem_id: 8\tTime: 5\tMemory: 3284*/#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int T;int main()&#123;    cin &gt;&gt; T;    while (T --)    &#123;                int a, b, c, d, e, f, g, h;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; f &gt;&gt; g &gt;&gt; h;        int res = (a * c) / b + (d * g * h) / (e * f);        cout &lt;&lt; res &lt;&lt; endl;    &#125;            return 0;&#125;\n","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/E10-2015%E7%BA%A7C++%E6%9C%9F%E6%9C%AB%E4%B8%8A%E6%9C%BA%E6%A8%A1%E6%8B%9F%E8%B5%9B/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/E2-2015%E7%BA%A7C++%E7%AC%AC%E4%BA%8C%E6%AC%A1%E7%BB%83%E4%B9%A0/","content":"/*  Author: 武迪 Result: AC\tSubmission_id: 4095284 Created at: Sat Jan 08 2022 00:29:45 GMT+0800 (China Standard Time) Problem_id: 23\tTime: 2\tMemory: 3344*/#include &lt;iostream&gt;using namespace std;int a, b, c, t;bool fun(int a)&#123;    if (a &lt;= b)&#123;        t += 1;        return true;    &#125;    if (b &lt;= c) return false;    t += 1;    return fun(a - b + c);&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    while (n -- )    &#123;        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        t = 0;        bool res = fun(a);        if (res) cout &lt;&lt; t &lt;&lt; endl;        else cout &lt;&lt; &quot;fail&quot; &lt;&lt; endl;            &#125;    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4104212 Created at: Wed Feb 09 2022 22:28:47 GMT+0800 (China Standard Time) Problem_id: 25\tTime: 27\tMemory: 3400*/#include &lt;iostream&gt;using namespace std;bool isprime(int x)&#123;       if (x &lt; 2) return false;    for (int i = 2; i &lt;= x / i; i ++)        if (x % i == 0) return false;    return true;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while (T -- )    &#123;        int x;        scanf(&quot;%d&quot;, &amp;x);        if(isprime(x)) puts(&quot;Yes&quot;);        else puts(&quot;No&quot;);    &#125;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4099484 Created at: Thu Jan 20 2022 01:18:19 GMT+0800 (China Standard Time) Problem_id: 26\tTime: 3\tMemory: 2088*/#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123;    double x,y,z,a,b,c,max,t;int n,i,k,maxi;    while(scanf(&quot;%lf%lf%lf%d&quot;,&amp;x,&amp;y,&amp;z,&amp;n)==4)&#123;        max=0;maxi=1;        for(i=0;i&lt;n;i++)&#123;            scanf(&quot;%lf%lf%lf&quot;,&amp;a,&amp;b,&amp;c);            t=(a-x)*(a-x)+(b-y)*(b-y)+(c-z)*(c-z);            if(t&gt;max)&#123;max=t;maxi=i+1;&#125;    &#125;    scanf(&quot;%d&quot;,&amp;k);printf(&quot;%d %lf\\n&quot;,maxi,k*2*sqrt(max));    &#125;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4099683 Created at: Thu Jan 20 2022 23:00:23 GMT+0800 (China Standard Time) Problem_id: 28\tTime: 4\tMemory: 3276*/#include &lt;iostream&gt;using namespace std;int valid(int x)&#123;    int n = x, sum = 0;    while (n)&#123;        int r = n % 10;        sum += r * r * r;        n /= 10;    &#125;    if (sum == x) return 1;    return 0;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while (T --)&#123;        int a, b, exist = 0;        cin &gt;&gt; a &gt;&gt; b;        for ( int i = a; i &lt;= b; i ++)&#123;            if (valid(i)) cout &lt;&lt; i &lt;&lt; &#x27; &#x27;, exist = 1;        &#125;                if(!exist) cout &lt;&lt; -1 &lt;&lt; endl;        else cout &lt;&lt; endl;    &#125;    return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4095285 Created at: Sat Jan 08 2022 00:47:14 GMT+0800 (China Standard Time) Problem_id: 30\tTime: 2\tMemory: 3456*/#include &lt;iostream&gt;using namespace std;int gcd(int n, int m)&#123;    int t;    while (m != 0)    &#123;        t = n % m;        n = m;        m = t;    &#125;    return n;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while (T -- )    &#123;           int a, b, c, d;        scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);        int e = a * d + c * b;        int f = b * d;        int r = gcd(e, f);        cout &lt;&lt; e / r &lt;&lt; &#x27; &#x27; &lt;&lt; f / r &lt;&lt; endl;    &#125;    return 0;&#125;\n","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/E3-2015%E7%BA%A7C++%E7%AC%AC%E4%B8%89%E6%AC%A1%E7%BB%83%E4%B9%A0/","content":"/*  Author: 武迪 Result: AC\tSubmission_id: 4098121 Created at: Wed Jan 12 2022 18:31:06 GMT+0800 (China Standard Time) Problem_id: 42\tTime: 11\tMemory: 3716*/#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int q[N], a[N], hh, tt;int main()&#123;    int n;    while (scanf(&quot;%d&quot;, &amp;n) != EOF)&#123;                for (int i = 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;a[i]);            int res = -999998;        hh = 0, tt = -1;        for (int i = 0; i &lt; n; i ++ )&#123;            if (i == 0)&#123;                q[++tt] = a[i];            &#125;else &#123;                while (hh &lt;= tt &amp;&amp; q[tt] &lt; a[i]) tt--;                // cout &lt;&lt; q[hh] &lt;&lt; endl;                res = max(res, q[hh] - a[i]);                q[++tt] = a[i];            &#125;        &#125;        printf(&quot;%d\\n&quot;, res);    &#125;    return 0;&#125;\n","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/E4-2015%E7%BA%A7C++%E7%AC%AC%E5%9B%9B%E6%AC%A1%E7%BB%83%E4%B9%A0/","content":"/*  Author: 武迪 Result: AC\tSubmission_id: 4099478 Created at: Thu Jan 20 2022 00:45:51 GMT+0800 (China Standard Time) Problem_id: 72\tTime: 2\tMemory: 3336*/#include &lt;iostream&gt;using namespace std;int main()&#123;    int n;    string s;    while (cin &gt;&gt; n &gt;&gt; s)&#123;        int flag = 0;        for (int i = 2; i &lt;= n; i ++)&#123;            if (s[i] - s[i - 1] == 1 &amp;&amp; s[i] - s[ i - 2] == 2) &#123;                flag = 1;                break;            &#125;        &#125;        if (flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;    &#125;        return 0;&#125;\n/*  Author: 武迪 Result: AC\tSubmission_id: 4104214 Created at: Wed Feb 09 2022 22:34:17 GMT+0800 (China Standard Time) Problem_id: 76\tTime: 15\tMemory: 3156*/#include &lt;iostream&gt;using namespace std;typedef long long LL;bool isprime(LL x)&#123;       if (x &lt; 2) return false;    for (int i = 2; i &lt;= x / i; i ++)        if (x % i == 0) return false;    return true;&#125;int main()&#123;    LL x;    while (cin &gt;&gt; x)    &#123;        if (isprime(x)) cout &lt;&lt; &quot;jhljx is good!&quot; &lt;&lt; endl;        else cout &lt;&lt; &quot;jhljx is sangxinbingkuang!&quot; &lt;&lt; endl;    &#125;&#125;\n","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/E5-2015%E7%BA%A7C++%E7%AC%AC%E4%BA%94%E6%AC%A1%E7%BB%83%E4%B9%A0/","content":"/*  Author: 武迪 Result: AC\tSubmission_id: 4104225 Created at: Wed Feb 09 2022 23:05:23 GMT+0800 (China Standard Time) Problem_id: 92\tTime: 3\tMemory: 3280*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1e6 + 10;void get_primes(int x)&#123;    vector&lt;PII&gt; primes;    for (int i = 2; i &lt;= x / i; i ++)    &#123;        if (x % i == 0)        &#123;            int r = 0;            while (x % i == 0) x /= i, r ++;            primes.push_back(&#123;i, r&#125;);        &#125;    &#125;    if (x &gt; 1) primes.push_back(&#123;x, 1&#125;);        for (int i = 0; i &lt; primes.size(); i ++)    &#123;        int prime = primes[i].first, idx = primes[i].second;        while(idx)        &#123;            if(i == primes.size() - 1 &amp;&amp; idx == 1)                cout &lt;&lt; prime;            else                cout &lt;&lt; prime &lt;&lt; &#x27;*&#x27;;            idx --;        &#125;    &#125;    puts(&quot;&quot;);&#125;int main()&#123;    int x;    while (cin &gt;&gt; x)    &#123;        if (x == 1) cout &lt;&lt; x &lt;&lt; endl;        else get_primes(x);    &#125;&#125;\n","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/E6-2015%E7%BA%A7C++%E7%AC%AC%E5%85%AD%E6%AC%A1%E7%BB%83%E4%B9%A0%E8%B5%9B/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/E7-2015%E7%BA%A7C++%E7%AC%AC%E4%B8%83%E6%AC%A1%E7%BB%83%E4%B9%A0%E8%B5%9B/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/E8-2015%E7%BA%A7C++%E7%AC%AC%E5%85%AB%E6%AC%A1%E7%BB%83%E4%B9%A0%E8%B5%9B/","content":"/*  Author: 武迪 Result: AC\tSubmission_id: 4095416 Created at: Sat Jan 08 2022 22:15:03 GMT+0800 (China Standard Time) Problem_id: 158\tTime: 10\tMemory: 3448*/#include &lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;int main()&#123;    int n;    while (scanf(&quot;%d&quot;, &amp;n) != EOF)    &#123;           vector&lt;PII&gt; segs;        for (int i = 0; i &lt; n; i ++ ) &#123;            int l, r;            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);            segs.push_back(&#123;l, r&#125;);        &#125;        sort(segs.begin(), segs.end());                for (auto seg : segs)            printf(&quot;%d %d\\n&quot;, seg.first, seg.second);            &#125;    return 0;&#125;\n","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/E9-2015%E7%BA%A7C++%E7%AC%AC%E4%B9%9D%E6%AC%A1%E7%BB%83%E4%B9%A0%E8%B5%9B/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2015级-软件学院C++程序设计 - 第一次上机","url":"/2022/02/20/algorithm/oj4th/2015%E7%BA%A7-%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2-C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/Final-2015%E7%BA%A7C++%E6%9C%9F%E6%9C%AB%E4%B8%8A%E6%9C%BA/","content":"","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"2021级《C语言程序设计基础题解与实训指南》专项练习","url":"/2022/02/20/algorithm/oj4th/2021%E7%BA%A7-%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E9%A2%98%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%AE%AD%E6%8C%87%E5%8D%97%E3%80%8B%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/","content":"专项练习1: 基本数据处理A 题2-1 简单字符(串)输出:颜文字表情图案绘制/*  Author: wudi Result: AC\tSubmission_id: 4098725 Created at: Sun Jan 16 2022 16:59:21 GMT+0800 (China Standard Time) Problem_id: 4542\tTime: 1\tMemory: 1460*/#include &lt;stdio.h&gt;int main()&#123;        printf(&quot;\\&quot;\\\\(^_^ )/\\&quot;&quot;);        return 0;&#125;\nB 题2-2 简单字符(串)输出:转义符应用/*  Author: wudi Result: AC\tSubmission_id: 4098726 Created at: Sun Jan 16 2022 17:00:54 GMT+0800 (China Standard Time) Problem_id: 4543\tTime: 1\tMemory: 1396*/#include &lt;stdio.h&gt;int main()&#123;        printf(&quot;? *&amp;\\\\! _//\\\\a@\\\\\\\\\\\\r\\\\n! //\\\\\\\\\\&quot;_\\&quot;/\\\\\\\\^! ~zZ&quot;);        return 0;&#125;\nC 题2-3 基本输入输出及运算:数的向上取整/*  Author: wudi Result: AC\tSubmission_id: 4098730 Created at: Sun Jan 16 2022 17:03:59 GMT+0800 (China Standard Time) Problem_id: 4544\tTime: 7\tMemory: 1640*/#include &lt;stdio.h&gt;int main()&#123;        int n, m;    scanf(&quot;%d%d&quot;, &amp;n ,&amp;m);        int r = n / m;    if (r * m == n) printf(&quot;%d&quot;, r);    else printf(&quot;%d&quot;, r + 1);        return 0;&#125;\nD 题2-4 基本输入输出及运算:计算预期收益/*  Author: wudi Result: AC\tSubmission_id: 4098733 Created at: Sun Jan 16 2022 17:09:28 GMT+0800 (China Standard Time) Problem_id: 4545\tTime: 2\tMemory: 1716*/#include &lt;stdio.h&gt;int main()&#123;        float a, c;    scanf(&quot;%f%f&quot;, &amp;a, &amp;c);    double s = a * (1 + c / 100);    printf(&quot;%.2f&quot;, s);        return 0;&#125;\nE 题2-5 基本输入输出及运算:计算平均值/*  Author: wudi Result: AC\tSubmission_id: 4098740 Created at: Sun Jan 16 2022 17:23:59 GMT+0800 (China Standard Time) Problem_id: 4546\tTime: 0\tMemory: 1688*/#include &lt;stdio.h&gt;int main()&#123;        float a, b, c;    scanf(&quot;%f%f%f&quot;, &amp;a, &amp;b, &amp;c);    float s = (a + b + c) / 3;    printf(&quot;%.1f&quot;, s);        return 0;&#125;\nF 题2-6 基本输入输出及运算:计算圆柱体表面积/*  Author: wudi Result: AC\tSubmission_id: 4098745 Created at: Sun Jan 16 2022 17:29:00 GMT+0800 (China Standard Time) Problem_id: 4547\tTime: 2\tMemory: 1668*/#include &lt;stdio.h&gt;int main()&#123;        float r, h;    float pi = 3.14;    scanf(&quot;%f%f&quot;, &amp;r, &amp;h);    float area = 2 * pi * r * h + pi * r * r * 2;    printf(&quot;Area = %.3f&quot;, area);        return 0;&#125;\nG 题2-7 模运算:简单取模操作/*  Author: wudi Result: AC\tSubmission_id: 4098758 Created at: Sun Jan 16 2022 19:06:24 GMT+0800 (China Standard Time) Problem_id: 4548\tTime: 6\tMemory: 1700*/#include &lt;stdio.h&gt;int main()&#123;    unsigned long long n;    scanf(&quot;%llu&quot;, &amp;n);    long long res = (3 * n  + 1) % 100000007;    printf(&quot;%llu&quot;, res);        return 0;&#125;\nH 题2-8 模运算:数的按位拆分/*  Author: wudi Result: AC\tSubmission_id: 4098759 Created at: Sun Jan 16 2022 19:11:14 GMT+0800 (China Standard Time) Problem_id: 4549\tTime: 2\tMemory: 1592*/#include &lt;stdio.h&gt;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    int L = 0, i = 1;    while (n)&#123;        int r = n % 10;        n /= 10;        L += i * r;        i ++;    &#125;    printf(&quot;%d&quot;, L);    return 0;&#125;\nI 题2-9 模运算:数位翻转/*  Author: wudi Result: AC\tSubmission_id: 4098770 Created at: Sun Jan 16 2022 19:59:59 GMT+0800 (China Standard Time) Problem_id: 4550\tTime: 3\tMemory: 1728*/#include &lt;stdio.h&gt;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    int l = n / 10000 * 10000;    n %= 10000;    int i = 1000, last = 0;    while (n)&#123;        int r = n % 10;        last += i * r;        n /= 10;;        i /= 10;    &#125;    printf(&quot;%d&quot;, l + last);    return 0;&#125;\nJ 题2-10 模运算:学号识别码/*  Author: wudi Result: AC\tSubmission_id: 4098773 Created at: Sun Jan 16 2022 20:10:04 GMT+0800 (China Standard Time) Problem_id: 4551\tTime: 2\tMemory: 1692*/#include &lt;stdio.h&gt;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    int i = 2, res = 0, raw = n;    while (n)&#123;        int r = n % 10;        res += i * r;        n /= 10;        i ++;    &#125;    printf(&quot;%d&quot;,  raw * 10 + res % 10);    return 0;&#125;\nK 题2-11 模运算:队列找字母/*  Author: wudi Result: AC\tSubmission_id: 4098777 Created at: Sun Jan 16 2022 20:23:15 GMT+0800 (China Standard Time) Problem_id: 4552\tTime: 2\tMemory: 1544*/#include &lt;stdio.h&gt;int main()&#123;    char s[7] = &quot;abcdefg&quot;;    int n;    scanf(&quot;%d&quot;, &amp;n);    printf(&quot;%c&quot;, s[n % 7 - 1]);    return 0;&#125;\nL 题2-12 模运算:火仙草数/*  Author: wudi Result: AC\tSubmission_id: 4098777 Created at: Sun Jan 16 2022 20:23:15 GMT+0800 (China Standard Time) Problem_id: 4552\tTime: 2\tMemory: 1544*/#include &lt;stdio.h&gt;int main()&#123;    char s[7] = &quot;abcdefg&quot;;    int n;    scanf(&quot;%d&quot;, &amp;n);    printf(&quot;%c&quot;, s[n % 7 - 1]);    return 0;&#125;\nM 题2-13 数据类型转换:分数转小数/*  Author: wudi Result: AC\tSubmission_id: 4098827 Created at: Sun Jan 16 2022 22:08:30 GMT+0800 (China Standard Time) Problem_id: 4554\tTime: 1\tMemory: 1640*/#include &lt;stdio.h&gt;int main()&#123;    int a, b;    scanf(&quot;%d/%d&quot;, &amp;a, &amp;b);    double res = a;    res /= b;    printf(&quot;%.2f&quot;, res);    return 0;&#125;\nN 题2-14 位运算:A op B Problem/*  Author: wudi Result: AC\tSubmission_id: 4098825 Created at: Sun Jan 16 2022 21:55:18 GMT+0800 (China Standard Time) Problem_id: 4555\tTime: 119\tMemory: 1664*/#include &lt;stdio.h&gt;int main()&#123;    int q;    scanf(&quot;%lld&quot;, &amp;q);    while (q --)&#123;        unsigned int a, b;        scanf(&quot;%u%u&quot;, &amp;a, &amp;b);        // printf(&quot;%lld %lld\\n&quot;, a, b);        int w0, w1, w2, w3;        scanf(&quot;%u%u%u%u&quot;, &amp;w0, &amp;w1, &amp;w2, &amp;w3);        int c = 0;        unsigned long long res = 0;        for(int i = 31; i &gt;= 0; i --)&#123;            int a0 = a &gt;&gt; i &amp; 1;            int b0 = b &gt;&gt; i &amp; 1;            if (a0 == 0 &amp;&amp; b0 == 0) c = w0;            if (a0 == 0 &amp;&amp; b0 == 1) c = w1;            if (a0 == 1 &amp;&amp; b0 == 0) c = w2;            if (a0 == 1 &amp;&amp; b0 == 1) c = w3;            res += c &lt;&lt; i;        &#125;        if(q) printf(&quot;%u\\n&quot;, res);        else printf(&quot;%u&quot;, res);    &#125;    return 0;&#125;\n专项练习2: 结构化编程（❌）J, M未完成\nA 题3-1 逻辑表达式的应用：名次预测/*  Author: wudi Result: AC\tSubmission_id: 4098828 Created at: Sun Jan 16 2022 22:20:01 GMT+0800 (China Standard Time) Problem_id: 4556\tTime: 6\tMemory: 1704*/#include &lt;stdio.h&gt;int main()&#123;    int i = 1, cnt = 0;    while (i &lt;= 6)&#123;        int n;        scanf(&quot;%d&quot;, &amp;n);        if (n == i) cnt ++;        i ++;    &#125;    if (cnt == 0) printf(&quot;Sorry!Unlucky!&quot;);    else&#123;        while (cnt --) printf(&quot;*&quot;);    &#125;    return 0;&#125;\nB 题3-2 单分支选择结构:寻找第二小数/*  Author: wudi Result: AC\tSubmission_id: 4098829 Created at: Sun Jan 16 2022 22:28:09 GMT+0800 (China Standard Time) Problem_id: 4557\tTime: 1\tMemory: 1664*/#include &lt;stdio.h&gt;int main()&#123;    int a, b, c;    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);    if ( a &gt;= b)&#123;        int temp = a;        a = b;        b = temp;    &#125;    if (b &gt;= c)&#123;        int temp = b;        b = c;        c = temp;    &#125;    if (a &gt;= b) printf(&quot;%d&quot;, a);    else printf(&quot;%d&quot;, b);        return 0;&#125;\nC 题3-3 单分支选择结构:重逢时刻/*  Author: wudi Result: AC\tSubmission_id: 4099087 Created at: Tue Jan 18 2022 12:41:36 GMT+0800 (China Standard Time) Problem_id: 4558\tTime: 20\tMemory: 1720*/#include &lt;stdio.h&gt;int main()&#123;        int n;    scanf(&quot;%d&quot;, &amp;n);    n %= 12;    int hh, mm;    double ss;    if (n == 0 || n == 11)&#123;        hh = 0;        mm = 0;        ss = 0.0;    &#125;    else &#123;        double t = n + n / 11.0;        hh = t;        mm = (t - hh) * 60;        ss = t * 3600 - hh * 3600 - mm * 60;    &#125;    printf(&quot;%d:%d:%.7f\\n&quot;, hh, mm, ss);        return 0;&#125;\nD 题3-4 单分支选择结构:方程求解/*  Author: wudi Result: AC\tSubmission_id: 4099119 Created at: Tue Jan 18 2022 14:17:48 GMT+0800 (China Standard Time) Problem_id: 4559\tTime: 7\tMemory: 2128*/#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123;        long long a, b, c;    while (scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;c) != EOF)&#123;                if (a &amp;&amp; b)&#123;            if (b * b &gt; 4 * a * c)&#123;                double x1 = 2.0 * a / (-1.0 * b + sqrt(1.0 * b * b - 4.0 * a * c));                double x2 = 2.0 * a / (-1.0 * b - sqrt(1.0 * b * b - 4.0 * a * c));                if (x1 &gt; x2) printf(&quot;%.2lf %.2lf\\n&quot;, x2, x1);                else printf(&quot;%.2lf %.2lf\\n&quot;, x1, x2);            &#125;            else if (b * b == 4 * a * c)&#123;                double x = (2.0 * a) / (-1.0 * b);                printf(&quot;%.2lf\\n&quot;, x);            &#125;            else printf(&quot;NO Solution\\n&quot;);        &#125;        else if (!a &amp;&amp; b)&#123;            double x = - 1.00 * b / c;            printf(&quot;%.2lf\\n&quot;, x);        &#125;        else if (a &amp;&amp; !b)&#123;            if (c &gt; 0) printf(&quot;NO Solution\\n&quot;);            else &#123;                double x1 = sqrt(-1.00 * a / c);                double x2 = -1.00 * sqrt(-1.00 * a / c);                printf(&quot;%.2lf %.2lf\\n&quot;, x2, x1);            &#125;        &#125;        else if (!a &amp;&amp; !b)&#123;            printf(&quot;NO Solution\\n&quot;);        &#125;    &#125;        return 0;&#125;\nE 题3-5 双分支选择结构:直线与圆/*  Author: wudi Result: AC\tSubmission_id: 4099132 Created at: Tue Jan 18 2022 15:06:35 GMT+0800 (China Standard Time) Problem_id: 4560\tTime: 8\tMemory: 2076*/#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main()&#123;        double x1, y1, x2, y2, x3, y3, r;    double a, b, c, l;    while (scanf(&quot;%lf%lf%lf%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;x3, &amp;y3, &amp;r) != EOF)&#123;        // printf(&quot;%lf %lf %lf %lf %lf %lf %lf\\n&quot;,x1, y1, x2, y2, x3, y3, r);        if (x1 == x2 &amp;&amp; y1 != y2)&#123;            l = fabs(x3 - x1);        &#125;        else if (x1 != x2 &amp;&amp; y1 == y2)&#123;            l = fabs(y3 - y1);        &#125;        else if (x1 == x2 &amp;&amp; y1 == y2)&#123;            l = sqrt((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1));        &#125;        else if (x1 != x2 &amp;&amp; y1 != y2)&#123;            a = (y1 - y2) / (x1 - x2);            b = - 1.00;            c = (x1 * y2 - x2 * y1) / (x1 - x2);            l = fabs(a * x3 + b * y3 + c) / (sqrt(a * a + b * b));        &#125;                // printf(&quot;%lf %lf\\n&quot;, l, r);        if (l &lt; r) printf(&quot;2\\n&quot;);        else if (l == r) printf(&quot;1\\n&quot;);        else printf(&quot;0\\n&quot;);             &#125;            return 0;&#125;\nF 题3-6 双分支选择结构:温度转换/*  Author: wudi Result: AC\tSubmission_id: 4099145 Created at: Tue Jan 18 2022 15:45:06 GMT+0800 (China Standard Time) Problem_id: 4561\tTime: 7\tMemory: 1744*/#include &lt;stdio.h&gt;double floor(double x)&#123;    int res = x * 100;    if (res % 10 &lt; 5)&#123;        res /= 10;        x = res / 10.0;    &#125;    else &#123;        res = res / 10 + 1;         x = res / 10.0;    &#125;    return x;&#125;int main()&#123;        int n1, res;    double n2;    char T1, T2;    scanf(&quot;&lt;%d&gt;&lt;%c&gt;&quot;, &amp;n1, &amp;T1);        if (T1 == &#x27;C&#x27;) &#123;        T2 = &#x27;F&#x27;;        n2 = n1 * 9.00 / 5.00 + 32.0;            &#125;    else if (T1 == &#x27;F&#x27;)&#123;        T2 = &#x27;C&#x27;;        n2 = (n1 - 32.0) * (5.00 / 9.00);     &#125;    // printf(&quot;%lf\\n&quot;, n2);        if (n2 &gt; 0) n2 = floor(n2);    else n2 = -1.0 * floor(-1.0 * n2);    printf(&quot;&lt;%d&gt;&lt;%c&gt;=&lt;%.1lf&gt;&lt;%c&gt;&quot;, n1, T1, n2, T2);            return 0;&#125;\nG 题3-7 双分支选择结构:统计阶乘的尾数0/*  Author: wudi Result: AC\tSubmission_id: 4099164 Created at: Tue Jan 18 2022 16:23:48 GMT+0800 (China Standard Time) Problem_id: 4562\tTime: 13\tMemory: 1732*/#include &lt;stdio.h&gt;int cntZero(int n)&#123;    int sum = 0;    if (n == 0) return 0;    else &#123;        while (n)&#123;            sum += n / 5;            n /= 5;        &#125;    &#125;    return sum;&#125;int main()&#123;        int n, cnt = 0;    scanf(&quot;%d&quot;, &amp;n);        for (int i = 0; i &lt;= n; i ++)&#123;        int num = cntZero(i);        // printf(&quot;%i : %d\\n&quot;,i, num);        if (num % 2 == 0) cnt ++;    &#125;    printf(&quot;%d&quot;, cnt);        return 0;&#125;\nH 题3-8 双分支选择结构:字符大小写转换/*  Author: wudi Result: AC\tSubmission_id: 4099176 Created at: Tue Jan 18 2022 16:36:23 GMT+0800 (China Standard Time) Problem_id: 4563\tTime: 6\tMemory: 1692*/#include &lt;stdio.h&gt;const int N = 100010;int main()&#123;        char link[N], pwd[N];    scanf(&quot;%s&quot;, link);    scanf(&quot;%s&quot;, pwd);        for (int i = 0; link[i]; i ++)&#123;        if (link[i] - &#x27;Z&#x27; &lt;= 0 &amp;&amp; link[i] - &#x27;A&#x27; &gt;= 0)&#123;            // 为大写字母            link[i] = link[i] - &#x27;A&#x27; + &#x27;a&#x27;;        &#125;        else if (link[i] - &#x27;z&#x27; &lt;= 0 &amp;&amp; link[i] - &#x27;a&#x27; &gt;= 0)&#123;            // 为小写字母            link[i] = link[i] -&#x27;a&#x27; + &#x27;A&#x27;;        &#125;        printf(&quot;%c&quot;, link[i]);    &#125;    printf(&quot;\\n&quot;);    for (int i = 0; pwd[i]; i ++)&#123;        if (pwd[i] - &#x27;Z&#x27; &lt;= 0 &amp;&amp; pwd[i] - &#x27;A&#x27; &gt;= 0)&#123;            // 为大写字母            pwd[i] = pwd[i] - &#x27;A&#x27; + &#x27;a&#x27;;        &#125;        else if (pwd[i] - &#x27;z&#x27; &lt;= 0 &amp;&amp; pwd[i] - &#x27;a&#x27; &gt;= 0)&#123;            // 为小写字母            pwd[i] = pwd[i] -&#x27;a&#x27; + &#x27;A&#x27;;        &#125;        printf(&quot;%c&quot;, pwd[i]);    &#125;        return 0;&#125;\nI 题3-9 多分支条件语句:求解分段函数/*  Author: wudi Result: AC\tSubmission_id: 4099178 Created at: Tue Jan 18 2022 16:39:28 GMT+0800 (China Standard Time) Problem_id: 4564\tTime: 3\tMemory: 1684*/#include &lt;stdio.h&gt;int main()&#123;    long long x, y;    scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);    if (x &lt; 1) y = x;    else if (x &gt;= 1 &amp;&amp; x &lt; 10) y = 2 * x - 3;    else if (x &gt;= 10) y = 3 * x - 5;    printf(&quot;%lld&quot;, y);        return 0;&#125;\nJ 题3-10 多分支条件语句:窗口的嵌套(❌)K 题3-11 多路选择的switch语句:简单计算器/*  Author: wudi Result: AC\tSubmission_id: 4099252 Created at: Tue Jan 18 2022 21:00:28 GMT+0800 (China Standard Time) Problem_id: 4566\tTime: 1\tMemory: 1700*/#include &lt;stdio.h&gt;double floor(double x)&#123;    if (x &lt; 0) return -1.0 * floor(-1.0 * x);    int res = x * 1000;    if (res % 10 &lt; 5)&#123;        res /= 10;        x = res / 100.0;    &#125;    else &#123;        res = res / 10 + 1;         x = res / 100.0;    &#125;    return x;&#125;int main()&#123;        char op;    double x, y, res;    scanf(&quot;%c&quot;, &amp;op);    scanf(&quot;%lf&quot;, &amp;x);    scanf(&quot;%lf&quot;, &amp;y);    if (op == &#x27;+&#x27;)&#123;        res = x + y;    &#125;    else if (op == &#x27;-&#x27;)&#123;        res = x - y;    &#125;    else if (op == &#x27;*&#x27;)&#123;        res = x * y;    &#125;    else if (op == &#x27;/&#x27;)&#123;        if (y != 0) res = x / y;    &#125;    if (y == 0 &amp;&amp; op == &#x27;/&#x27;)&#123;        printf(&quot;invalidexpression&quot;);    &#125;else &#123;        // res = floor(res);        printf(&quot;%.2lf&quot;, res);    &#125;        return 0;&#125;\nL 题3-12 选择结构的嵌套:交换生条件审核/*  Author: wudi Result: AC\tSubmission_id: 4099265 Created at: Tue Jan 18 2022 22:23:03 GMT+0800 (China Standard Time) Problem_id: 4567\tTime: 2\tMemory: 1744*/#include &lt;stdio.h&gt;double avg(double a, double b, double c)&#123;    return (a + b + c) / 3.0;&#125;int main()&#123;        int flag;    double gpa;    double a1, b1, c1, a2, b2, c2;    scanf(&quot;%d%lf&quot;, &amp;flag, &amp;gpa);    scanf(&quot;%lf%lf%lf&quot;, &amp;a1, &amp;b1, &amp;c1);    scanf(&quot;%lf%lf%lf&quot;, &amp;a2, &amp;b2, &amp;c2);        if(flag)&#123;        if (gpa &gt;= 3.5) printf(&quot;APPROVED&quot;);        else if (avg(a1, b1, c1) &gt;= 80 &amp;&amp; avg(a2, b2, c2) &gt;= 80) printf(&quot;APPROVED&quot;);        else printf(&quot;REJECTED&quot;);    &#125;     else &#123;        if (gpa &gt;= 3.6) printf(&quot;APPROVED&quot;);        else if (avg(a1, b1, c1) &gt; 85 &amp;&amp; avg(a2, b2, c2) &gt; 85) printf(&quot;APPROVED&quot;);        else printf(&quot;REJECTED&quot;);    &#125;        return 0;&#125;\nM 题3-13 选择结构的嵌套:观影计划(❌)不会写\nN 题3-14 多路分支选择结构:方向判断/*  Author: wudi Result: AC\tSubmission_id: 4104410 Created at: Thu Feb 10 2022 21:53:28 GMT+0800 (China Standard Time) Problem_id: 4569\tTime: 23\tMemory: 2384*/#include &lt;stdio.h&gt;#include &lt;math.h&gt;const double pi = 3.14159265;int main()&#123;        int x, y;    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);    if(x == 0 &amp;&amp; y == 0)        printf(&quot;Bingo\\n&quot;);    else if (x == 0 || y == 0)    &#123;        if (y == 0)        &#123;            if (x &gt; 0) printf(&quot;E\\n&quot;);            else printf(&quot;W\\n&quot;);        &#125;        else        &#123;            if (y &gt; 0) printf(&quot;N\\n&quot;);            else printf(&quot;S\\n&quot;);        &#125;            &#125;    else    &#123;        double deg = atan(abs(x) * 1.0 / abs(y)) * 180 / pi;        if (x &gt; 0 &amp;&amp; y &gt; 0) printf(&quot;NE%.2lf&quot;, deg);        if (x &gt; 0 &amp;&amp; y &lt; 0) printf(&quot;SE%.2lf&quot;, deg);        if (x &lt; 0 &amp;&amp; y &gt; 0) printf(&quot;NW%.2lf&quot;, deg);        if (x &lt; 0 &amp;&amp; y &lt; 0) printf(&quot;SW%.2lf&quot;, deg);    &#125;    return 0;&#125;\nO 题3-15 while循环(计数器控制):判断2的幂次数/*  Author: wudi Result: AC\tSubmission_id: 4104229 Created at: Wed Feb 09 2022 23:18:56 GMT+0800 (China Standard Time) Problem_id: 4570\tTime: 843\tMemory: 1652*/#include &lt;stdio.h&gt;typedef unsigned long long ULL;ULL lowbit(ULL x)  // 返回末尾的1&#123;    return x &amp; -x;&#125;int main()&#123;    int T;    scanf(&quot;%d&quot;, &amp;T);    while (T -- )    &#123;        ULL x;        scanf(&quot;%llu&quot;, &amp;x);        int res = 0;        while (x) x -= lowbit(x), res ++;        if (res == 1) printf(&quot;222\\n&quot;);        else printf(&quot;%d\\n&quot;, res);    &#125;&#125;\nP 题3-16 while循环(标志控制):破译密码/*  Author: wudi Result: AC\tSubmission_id: 4104234 Created at: Wed Feb 09 2022 23:28:57 GMT+0800 (China Standard Time) Problem_id: 4571\tTime: 5\tMemory: 1612*/#include &lt;stdio.h&gt;int main()&#123;    char s[110];    scanf(&quot;%s&quot;, s);    for (int i = 0; s[i]; i ++)    &#123;           s[i] += 4;    &#125;    printf(&quot;%s&quot;, s);&#125;\nQ 题3-17 dowhile循环(标志控制):士兵站队/*  Author: wudi Result: AC\tSubmission_id: 4104415 Created at: Thu Feb 10 2022 22:01:06 GMT+0800 (China Standard Time) Problem_id: 4572\tTime: 3\tMemory: 1732*/#include &lt;stdio.h&gt;int main()&#123;    int a, b, c, x, y, z;    scanf(&quot;%d%d&quot;, &amp;a, &amp;x);    scanf(&quot;%d%d&quot;, &amp;b, &amp;y);    scanf(&quot;%d%d&quot;, &amp;c, &amp;z);        int n = 1;    do n ++; while(n % a != x || n % b != y || n % c != z);    printf(&quot;%d\\n&quot;, n);        return 0;&#125;\nR 题3-18 for循环(计数器控制):日历计算/*  Author: wudi Result: AC\tSubmission_id: 4105552 Created at: Tue Feb 15 2022 23:33:09 GMT+0800 (China Standard Time) Problem_id: 4573\tTime: 10\tMemory: 1664*/#include &lt;stdio.h&gt;int Day(int yy, int mm, int dd)&#123;    int month[] = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;    int n1 = yy / 4 - yy / 100 + yy / 400;    int n2 = 1900 / 4 - 1900 / 100 + 1900 / 400;    n1 -= n2;    if (yy % 400 == 0 || yy % 100 != 0 &amp;&amp; yy % 4 == 0) month[1] = 29, n1 --;    for (int i = 1; i &lt; mm; i ++ ) dd += month[i - 1];        return 365 * (yy - 1900) + n1 + dd;&#125;int main()&#123;    int m, n;    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);    int month[12] = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;    if (m % 400 == 0 || m % 100 != 0 &amp;&amp; m % 4 == 0) month[1] = 29;    // 计算天数    int days = Day(m, n, 1);    // 计算n月1日是周几    int week = days % 7;    // printf(&quot;weeks:%d\\n&quot;, week);    printf(&quot; Sun Mon Tue Wed Thu Fri Sat\\n&quot;);    for(int i = 0; i &lt; week; i ++) printf(&quot;    &quot;);    for (int i = 1; i &lt;= month[n - 1]; i ++ )    &#123;        printf(&quot; %3d&quot;, i);        if ((i+ week) % 7 == 0) printf(&quot;\\n&quot;);    &#125;    return 0;&#125;\nS 题3-19 for循环(计数器控制):求数列的一项/*  Author: wudi Result: AC\tSubmission_id: 4104431 Created at: Thu Feb 10 2022 22:36:03 GMT+0800 (China Standard Time) Problem_id: 4574\tTime: 3\tMemory: 1664*/#include &lt;stdio.h&gt;typedef long long LL;const int N = 60;int main()&#123;    long long a[N];    a[1] = 1;    a[2] = 1;    for(int i = 3; i &lt;= 50; i ++) a[i] = 2 * a[i - 2] + a[i - 1];        int n;    scanf(&quot;%d&quot;, &amp;n);    printf(&quot;%lld&quot;, a[n]);            return 0;&#125;\nT 题3-20 for循环:理财计划/*  Author: wudi Result: AC\tSubmission_id: 4104447 Created at: Thu Feb 10 2022 23:09:20 GMT+0800 (China Standard Time) Problem_id: 4575\tTime: 2\tMemory: 1652*/#include &lt;stdio.h&gt;int main()&#123;    int pay[12];    int bank = 0, me = 0;    for ( int i = 0; i &lt; 12 ; i ++ ) scanf(&quot;%d&quot;, &amp;pay[i]);    int month = 0;    for (int i = 0; i &lt; 12; i ++ )    &#123;        me = me + 300 - pay[i];        if (me &lt; 0)         &#123;            if(!month) month = i + 1;            me = 0;        &#125;        else         &#123;            bank = bank + me / 100 * 100;            me %= 100;        &#125;        // printf(&quot;bank:%d me:%d\\n&quot;, bank, me);    &#125;    if(month) printf(&quot;-%d\\n&quot;, month);    else printf(&quot;%d\\n&quot;, 120 * bank / 100 + me);            return 0;&#125;\nU 题3-21 循环嵌套:寻找完数/*  Author: wudi Result: AC\tSubmission_id: 4104468 Created at: Fri Feb 11 2022 00:02:44 GMT+0800 (China Standard Time) Problem_id: 4576\tTime: 3\tMemory: 1508*/#include &lt;stdio.h&gt;int main()&#123;        for (int n = 2; n &lt;= 1000; n ++ )    &#123;        int sum = 0, x = n;        for (int i = 1; i &lt; n; i ++)        &#123;            if (n % i == 0) sum += i;        &#125;        if (x == sum) printf(&quot;%d\\n&quot;, x);    &#125;        return 0;&#125;\nV 题3-22 循环嵌套:寻找质因数/*  Author: wudi Result: AC\tSubmission_id: 4104470 Created at: Fri Feb 11 2022 00:07:56 GMT+0800 (China Standard Time) Problem_id: 4577\tTime: 13\tMemory: 1700*/#include &lt;stdio.h&gt;void divid(int x)&#123;    for (int i = 2; i &lt;= x / i; i ++)    &#123;        if(x % i == 0)        &#123;            while (x % i == 0) x /= i, printf(&quot;%d &quot;, i);        &#125;    &#125;    if (x &gt; 1) printf(&quot;%d &quot;, x);&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    divid(n);        return 0;&#125;\nW 题3-23 循环嵌套:等式填空/*  Author: wudi Result: AC\tSubmission_id: 4104637 Created at: Fri Feb 11 2022 22:38:45 GMT+0800 (China Standard Time) Problem_id: 4578\tTime: 1\tMemory: 1628*/#include &lt;stdio.h&gt;int main()&#123;    int m;    int a, b, c, d;    scanf(&quot;%d&quot;, &amp;m);    while (m -- )    &#123;        scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);        int exist = 0;        int cnt = 0;        for (int e = 0; e &lt; 10; e ++)            for (int f = 0; f &lt; 10; f ++)                for (int g = 0; g &lt; 10; g ++)                    for (int h = 0; h &lt; 10; h ++)                    &#123;                        if ((100 * a * f + 10 * a * b + 10 * f * e + e * b - 1000 * g - 100 * c - 10 * d - h) == 0)                        &#123;                            exist = 1;                            cnt ++;                            printf(&quot;case%d: %d%d*%d%d=%d%d%d%d\\n&quot;, cnt, a, e, f, b, g, c, d, h);                        &#125;                    &#125;        if(!exist) printf(&quot;IMPOSSIBLE!\\n&quot;);    &#125;    return 0;&#125;\nX 题3-24 循环嵌套:最短正整数序列/*  Author: wudi Result: AC\tSubmission_id: 4104475 Created at: Fri Feb 11 2022 00:49:16 GMT+0800 (China Standard Time) Problem_id: 4579\tTime: 22\tMemory: 1704*/#include &lt;stdio.h&gt;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    int sum = 0, res = n, l = 1, r = n;    for (int i = 1, j = 1; i &lt; n; i ++)    &#123;        sum += i;        while(j &lt; i &amp;&amp; sum &gt; n)        &#123;            sum -= j;            j ++;        &#125;                if (sum == n)        &#123;            int t = i - j + 1;            if (res &gt;= t)            &#123;                res = t;                l = j;                r = i;            &#125;        &#125;    &#125;    if (res == n)        printf(&quot;-1\\n&quot;);    else    &#123;        printf(&quot;%d = &quot;, n);        for (int i = l; i &lt;= r; i ++ )        &#123;            if (i != r)                printf(&quot;%d + &quot;, i);            else             printf(&quot;%d&quot;, i);        &#125;    &#125;    return 0;&#125;\n专项练习3: 函数及其应用（❌）只做到H，后面还有几题\nA 题4-1 定义与调用函数:三角形的判断/*  Author: wudi Result: AC\tSubmission_id: 4104681 Created at: Sat Feb 12 2022 00:15:02 GMT+0800 (China Standard Time) Problem_id: 4580\tTime: 4\tMemory: 1732*/#include &lt;stdio.h&gt;int main()&#123;        int a, b, c;    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);    if ( a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a)    &#123;        if (a == b &amp;&amp; a == c &amp;&amp; b == c) printf(&quot;equilateral triangle!\\n&quot;);        else if(a == b || a == c || b == c) printf(&quot;isosceles triangle!\\n&quot;);        else printf(&quot;regular triangle!\\n&quot;);    &#125;    else printf(&quot;not a triangle!\\n&quot;);        return 0;&#125;\nB 题4-2 定义与调用函数:猜素数/*  Author: wudi Result: AC\tSubmission_id: 4104684 Created at: Sat Feb 12 2022 00:22:15 GMT+0800 (China Standard Time) Problem_id: 4581\tTime: 8\tMemory: 1668*/#include&lt;stdio.h&gt;int is_prime(int n)&#123;    if (n &lt; 2) return 0;    for( int i = 2; i &lt;= n / i; i ++ )    &#123;        if (n % i == 0) return 0;    &#125;    return 1;&#125;int main()&#123;    int n;    while(scanf(&quot;%d&quot;, &amp;n) != EOF)    &#123;        if(is_prime(n)) printf(&quot;yes\\n&quot;);        else printf(&quot;no\\n&quot;);    &#125;        return 0;&#125;\nC 题4-3 定义与调用函数:cos(x)级数展开式/*  Author: wudi Result: AC\tSubmission_id: 4104856 Created at: Sat Feb 12 2022 21:54:46 GMT+0800 (China Standard Time) Problem_id: 4582\tTime: 5\tMemory: 1716*/#include&lt;stdio.h&gt;int main()&#123;    double x;    int m;    scanf(&quot;%lf&quot;, &amp;x);    scanf(&quot;%d&quot;, &amp;m);    double sign = 1.0, sum = 0.0, r = 0.0;     int b = 1;    for (int i = 0; i &lt; m; i ++)    &#123;        if (i == 0) r = 1.0;        else r = -1.0 * r * x * x / ((2 * i) * (2 * i - 1));        sum += r;    &#125;    printf(&quot;%.8lf\\n&quot;, sum);        return 0;&#125;\nD 题4-4 定义与调用函数:分数相加与化简/*  Author: wudi Result: AC\tSubmission_id: 4104862 Created at: Sat Feb 12 2022 22:01:54 GMT+0800 (China Standard Time) Problem_id: 4583\tTime: 6\tMemory: 1652*/#include &lt;stdio.h&gt;int gcd(int a, int b)&#123;    return b? gcd(b, a % b):a;&#125;int main()&#123;    int t;    scanf(&quot;%d&quot;, &amp;t);    while( t -- )    &#123;        int a, b, c, d;        scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d);        int e = a * d + b * c;        int f = b * d;        int r = gcd(e, f);        e /= r;        f /= r;        printf(&quot;%d %d\\n&quot;, e, f);    &#125;        return 0;&#125;\nE 题4-5 定义与调用函数:星期几/*  Author: wudi Result: AC\tSubmission_id: 4105549 Created at: Tue Feb 15 2022 23:20:01 GMT+0800 (China Standard Time) Problem_id: 4584\tTime: 8\tMemory: 1656*/#include &lt;stdio.h&gt;int Day(int yy, int mm, int dd)&#123;    int month[] = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;    int n1 = yy / 4 - yy / 100 + yy / 400;    int n2 = 1582 / 4 - 1582 / 100 + 1582 / 400;    n1 -= n2;    if (yy % 400 == 0 || yy % 100 != 0 &amp;&amp; yy % 4 == 0) month[1] = 29, n1 --;    for (int i = 1; i &lt; mm; i ++ ) dd += month[i - 1];        return 365 * (yy - 1582) + n1 + dd;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    int yy = n / 10000;    int mm = n % 10000 / 100;    int dd = n % 100;    int days = Day(yy, mm, dd);        int week = (days % 7 + 4) % 7;    // printf(&quot;week:%d\\n&quot;, week);    switch(week)    &#123;        case 0: printf(&quot;Sun&quot;);break;        case 1: printf(&quot;Mon&quot;);break;        case 2: printf(&quot;Tue&quot;);break;        case 3: printf(&quot;Wed&quot;);break;        case 4: printf(&quot;Thu&quot;);break;        case 5: printf(&quot;Fri&quot;);break;        case 6: printf(&quot;Sat&quot;);break;        default:break;    &#125;        return 0;&#125;\nF 题4-7 全局变量的使用:熊猫序列/*  Author: wudi Result: AC\tSubmission_id: 4105578 Created at: Wed Feb 16 2022 09:46:21 GMT+0800 (China Standard Time) Problem_id: 4607\tTime: 12\tMemory: 1720*/#include&lt;stdio.h&gt;const int mod = 10000007;int a[101];int f(int n)&#123;    if(n &lt; 5) return a[n];    for (int i = 5; i &lt;=n; i ++ )        a[i] = a[i - 1] % mod + a[i - 4] % mod;    return a[n] % mod;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for(int i = 1; i &lt;= 4; i ++ ) a[i] = 1;    int res = f(n);    printf(&quot;%d\\n&quot;, res);    return 0;&#125;\nG 题4-10 标准库函数的应用:求面积/*  Author: wudi Result: AC\tSubmission_id: 4104871 Created at: Sat Feb 12 2022 22:17:42 GMT+0800 (China Standard Time) Problem_id: 4610\tTime: 21\tMemory: 2620*/#include&lt;stdio.h&gt;#include &lt;math.h&gt;const double eps = 1e-4;int main()&#123;    double n;    scanf(&quot;%lf&quot;, &amp;n);    double x = 0.0;    double s = 0.0;    while (x &lt;= n)    &#123;        s += eps * fabs(sin(x * x));        x += eps;    &#125;    printf(&quot;%.2lf\\n&quot;, s);    return 0;&#125;\nH 题4-11 递归函数:倒序输出/*  Author: wudi Result: AC\tSubmission_id: 4104873 Created at: Sat Feb 12 2022 22:23:12 GMT+0800 (China Standard Time) Problem_id: 4611\tTime: 10\tMemory: 1720*/#include &lt;stdio.h&gt;const int N = 100010;int main()&#123;    int a[N];    int x, i = 0;    while (scanf(&quot;%d&quot;, &amp;x) != EOF) a[i ++] = x;        while (i &gt; 0) printf(&quot;%d\\n&quot;, a[-- i]);    return 0;&#125;\n专项练习4: 数组与字符串及应用（❌）","categories":["算法与数据结构"],"tags":["oj4th"]},{"title":"acwing基础算法(3)：搜索与图论","url":"/2022/02/22/algorithm/acwing/%E5%9F%BA%E7%A1%80%E8%AF%BE/L3-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/","content":"DFS\nAcWing 842. 排列数字\n\n```cpp\ninclude using namespace std;\nconst int N = 100010;int n, path[N], st[N];\nvoid dfs(int u){\nif (u == n){\n    for (int i = 0; i &lt; n; i ++ ) printf(\"%d \", path[i]);\n    puts(\"\");\n    return;\n}\nfor (int i = 1; i &lt;= n; i ++ ){\n    if (!st[i]){\n        path[u] = i;\n        st[i] = true;\n        dfs(u + 1);\n        st[i] = false;\n    }\n}\n}\nint main(){\nscanf(\"%d\", &amp;n);\ndfs(0);\n\nreturn 0;\n}\n- AcWing 843. n-皇后问题#### 第一种搜索方式\ninclude using namespace std;const int N = 10;\n\n\nchar g[N][N];bool col[N], dg[N  2], udg[N  2];int n;\nvoid dfs(int u){\nif (u == n) {\n    for (int i = 0; i &lt; n; i ++ ) puts(g[i]);\n    puts(\"\");\n    return;\n}\nfor (int j = 0; j &lt; n; j ++ ){\n    if (!col[j] &amp;&amp; !dg[u + j] &amp;&amp; !udg[n + j - u]){\n        g[u][j] = 'Q';\n        col[j] = dg[u + j] = udg[n + j - u] = true;\n        dfs(u + 1);\n        g[u][j] = '.';\n        col[j] = dg[u + j] = udg[n + j - u] = false;\n    }\n}\n}\nint main(){    scanf(“%d”, &amp;n);    for (int i = 0; i &lt; n; i ++ )        for (int j = 0; j &lt; n; j ++ ) g[i][j] = ‘.’;\ndfs(0);\n\nreturn 0;\n}#### 第二种搜索方式```cpp#include &lt;iostream&gt;using namespace std;const int N = 10;char g[N][N];bool row[N], col[N], dg[N * 2], udg[N * 2];int n;void dfs(int x, int y, int s){    if (s &gt; n) return;    if (y == n) x++, y = 0;    if (x == n) {        if (s == n){            for (int i = 0; i &lt; n; i ++ ) puts(g[i]);            puts(\"\");        }        return;    }    g[x][y] = '.';    dfs(x, y + 1, s);    if (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; ! udg[n - x + y]){        g[x][y] = 'Q';        row[x] = col[y] = dg[x + y] = udg[n - x + y] = true;        dfs(x, y + 1, s + 1);        row[x] = col[y] = dg[x + y] = udg[n - x + y] = false;        g[x][y] = '.';    }}int main(){    scanf(\"%d\", &amp;n);        dfs(0, 0, 0);        return 0;}\nBFS\nAcWing 844. 走迷宫\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 110;typedef pair&lt;int, int&gt; PII;int g[N][N], d[N][N];int n, m;int bfs(){    queue&lt;PII&gt; q;    memset(d, -1, sizeof d);    q.push({0 ,0});    d[0][0] = 0;    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};        while (q.size()){        PII t = q.front();        q.pop();        for (int i = 0; i &lt; 4; i++){            int x = t.first + dx[i], y = t.second + dy[i];            if (x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; d[x][y] == -1 &amp;&amp; g[x][y] == 0){                d[x][y] = d[t.first][t.second] + 1;                q.push({x, y});            }        }       }        return d[n - 1][m - 1];}int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; n; i ++ )        for (int j = 0; j &lt; m; j ++) cin &gt;&gt; g[i][j];            cout &lt;&lt; bfs() &lt;&lt; endl;            return 0;}\n\nAcWing 845. 八数码\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;using namespace std;const int N = 18;int bfs(string state){    queue&lt;string&gt; q;    unordered_map&lt;string, int&gt; d;    q.push(state);    d[state] = 0;        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};    string end = \"12345678x\";    while (q.size()){        auto t = q.front();        q.pop();        if ( t == end) return d[t];        int distance = d[t];        int k = t.find('x');        int x = k / 3, y = k % 3;        for (int i = 0; i &lt; 4; i ++){            int a = x + dx[i], b = y + dy[i];            if (a &gt;= 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 3){                swap(t[3 * a + b], t[k]);                if (!d.count(t)){                    d[t] = distance + 1;                    q.push(t);                }                swap(t[3 * a + b], t[k]);            }        }    }    return -1;}int main(){    char s[2];    string state;    for (int i = 0; i &lt; 9; i ++ ){        cin &gt;&gt; s;        state += *s;    }        cout &lt;&lt; bfs(state) &lt;&lt; endl;        return 0;}\n树与图的深度遍历\nAcWing 846. 树的重心\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010, M = 2 * N;int h[N], e[M], ne[M], idx, n, ans=N;bool st[N];void add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;}int dfs(int u){    st[u] = true;    int size = 0, sum = 0;    for (int i = h[u]; i != -1; i = ne[i]){        int j = e[i];        if(st[j]) continue; // 父节点遍历过，不再遍历        int s = dfs(j);        size = max(size, s);        sum += s;    }    size = max(size, n - sum - 1);    ans = min(ans, size);    // cout &lt;&lt; \"u: \" &lt;&lt; u &lt;&lt; endl;    return sum + 1;}int main(){    memset(h, -1, sizeof h);    scanf(\"%d\", &amp;n);    for (int i = 0; i &lt; n - 1; i ++ ){        int a, b;        scanf(\"%d%d\", &amp;a, &amp;b);        add(a, b);        add(b, a); // 初始的结点不一定是根节点，不是双向的话无法遍历父节点    }    dfs(1);    cout &lt;&lt; ans &lt;&lt; endl;        return 0;}\n树与图的宽度遍历\nAcWing 847. 图中点的层次\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 100010;int h[N], e[N], ne[N], idx, d[N], n, m;// bool st[N];void add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;}int bfs(){        queue&lt;int&gt; q;    memset(d, -1, sizeof d);    q.push(1);    d[1] = 0;        while(q.size()){        int t = q.front();        q.pop();        for (int i = h[t]; i != -1; i = ne[i]){            int j = e[i];            if (d[j] == -1){                d[j] = d[t] + 1;                q.push(j);            }        }    }        return d[n];}int main(){    memset(h, -1, sizeof h);        scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; m; i ++ ){        int a, b;        scanf(\"%d%d\", &amp;a, &amp;b);        add(a, b);    }        cout &lt;&lt; bfs() &lt;&lt; endl;            return 0;}\n拓扑排序\nAcWing 848. 有向图的拓扑序列\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010;int h[N], e[N], ne[N], idx, d[N], q[N];int n, m;void add(int a, int b){    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}bool topsort(){    int hh = 0, tt = -1;    for (int i = 1; i &lt;= n; i ++ )        if(!d[i]) q[++ tt] = i;        while(hh &lt;= tt){                int t = q[hh ++];        for (int i = h[t]; i != -1; i = ne[i]){            int j = e[i];            d[j] --;            if (d[j] == 0){                q[ ++ tt] = j;            }        }    }    return tt == n - 1;    }int main(){        memset(h, -1, sizeof h);    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; m ; i ++ ){        int a, b;        scanf(\"%d%d\", &amp;a, &amp;b);        add(a, b);        d[b] ++;    }    if (topsort()){        for (int i = 0; i &lt; n; i ++ ) printf(\"%d \", q[i]);        puts(\"\");    }    else puts(\"-1\");        return 0;}\nDijkstra\nAcWing 849. Dijkstra求最短路 I \n\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 510;int n, m;int g[N][N], dist[N];bool st[N];int dijkstra(){        memset(dist, 0x3f, sizeof dist);    dist[1] = 0;        for (int i = 0; i &lt; n; i ++ ){                int t = -1;        for (int j = 1; j &lt;= n; j ++ )            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j;                for (int j = 1; j &lt;= n; j ++ ){            dist[j] = min(dist[j], dist[t] + g[t][j]);        }        st[t] = true;    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    memset(g, 0x3f, sizeof g);    while (m --){        int a, b, c;        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c);        // if (a == b) g[a][b] = 0;        // else g[a][b] = min(g[a][b], c);        g[a][b] = min(g[a][b], c);    }        cout &lt;&lt; dijkstra() &lt;&lt; endl;        return 0;}\n\nAcWing 850. Dijkstra求最短路 II\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 1e6 + 10;typedef pair&lt;int, int&gt; PII;int n, m;int h[N], e[N], w[N], ne[N], idx;int dist[N];bool st[N];void add(int a, int b, int c){    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;}int dijkstra(){    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    heap.push({0, 1}); // first: 距离, second: 编号        while (heap.size()){        auto t = heap.top();        heap.pop();                int distance = t.first, var = t.second;        if (st[var]) continue;        st[var] = true;        for (int i = h[var]; i != -1; i = ne[i]){            int j = e[i];            if (dist[j] &gt; dist[var] + w[i]){                dist[j] = dist[var] + w[i];                heap.push({dist[j], j});            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    memset(h, -1, sizeof h);    while (m -- ){        int a, b, c;        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c);        add(a, b, c);    }        cout &lt;&lt; dijkstra() &lt;&lt; endl;            return 0;}\nBellman-ford\nAcWing 853. 有边数限制的最短路\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 510, M = 10010;struct Edge{    int a, b, c;} edge[M];int dist[N], backup[N];int n, m, k;void bellman_ford(){    memset(dist, 0x3f, sizeof dist);    dist[1] = 0;    for (int i = 0; i &lt; k; i++ )    {        memcpy(backup, dist, sizeof dist);        for (int j = 0; j &lt; m; j ++ )        {            auto e = edge[j];            dist[e.b] = min(dist[e.b], backup[e.a] + e.c);        }    } }int main(){    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);    for (int i = 0; i &lt; m; i ++ ){        int a, b, c;        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c);        edge[i] = {a, b, c};    }        bellman_ford();    if (dist[n] &gt; 0x3f3f3f3f / 2) puts(\"impossible\");    else cout &lt;&lt; dist[n] &lt;&lt; endl;            return 0;}\nspfa\nAcWing 851. spfa求最短路\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 100010;int h[N], e[N], w[N], ne[N], idx;int q[N], dist[N];bool st[N];int n, m;void add(int a, int b, int c){        e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;}int spfa(){    memset(dist, 0x3f, sizeof dist);    queue&lt;int&gt; q;    q.push(1);    dist[1] = 0;        st[1] = true;        while(q.size()){        int t = q.front();        q.pop();        st[t] = false;                for (int i = h[t]; i != -1; i = ne[i]){            int j = e[i];            if (dist[j] &gt; dist[t] + w[i]){                dist[j] = dist[t] + w[i];                if (!st[j]){                    q.push(j);                    st[j] = true;                }            }        }    }        return dist[n];    }int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    memset(h, -1, sizeof h);        for (int i = 0; i &lt; m; i ++ ){        int a, b, c;        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c);        add(a, b, c);    }        int t = spfa();    if ( t == 0x3f3f3f3f) puts(\"impossible\");    else printf(\"%d\\n\", t);            return 0;}\n\nAcWing 852. spfa判断负环\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 2010, M = 10010;int h[N], e[M], w[M], ne[M], idx;int q[N], dist[N], cnt[N];bool st[N];int n, m;void add(int a, int b, int c){        e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++;}bool spfa(){    queue&lt;int&gt; q;    for (int i = 1; i &lt;=n; i ++){        q.push(i);        st[i] = true;    }        while(q.size()){        int t = q.front();        q.pop();        st[t] = false;                for (int i = h[t]; i != -1; i = ne[i]){            int j = e[i];            if (dist[j] &gt; dist[t] + w[i]){                dist[j] = dist[t] + w[i];                cnt[j] = cnt[t] + 1;                if (cnt[j] &gt;= n) return true;                if (!st[j]){                    q.push(j);                    st[j] = true;                }            }        }    }        return false;   }int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    memset(h, -1, sizeof h);        for (int i = 0; i &lt; m; i ++ ){        int a, b, c;        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c);        add(a, b, c);    }        if(spfa()) puts(\"Yes\");    else puts(\"No\");            return 0;}\nFloyd\nAcWing 854. Floyd求最短路\n\n#include &lt;iostream&gt;using namespace std;const int N = 210, INF = 1e9;int d[N][N];int n, m, Q;void floyd(){        for (int k = 1; k &lt;= n; k ++ )        for (int i = 1; i &lt;= n; i ++)            for (int j = 1; j &lt;= n; j ++)                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);  }int main(){    scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;Q);        for (int i = 1; i &lt;= n; i ++ )        for (int j = 1; j &lt;= n; j ++ ){            if (i == j) d[i][j] = 0;            else d[i][j] = INF;        }        for (int i = 0; i &lt; m; i ++ )    {        int a, b, c;        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c);        d[a][b] = min(d[a][b], c);    }        floyd();        while (Q -- ){        int x, y;        scanf(\"%d%d\", &amp;x, &amp;y);        if(d[x][y] &gt; INF / 2) puts(\"impossible\");        else printf(\"%d\\n\", d[x][y]);    }         return 0;}\nPrim\nAcWing 858. Prim算法求最小生成树\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 510, INF = 0x3f3f3f3f;int g[N][N], dist[N]; // dist表示点到集合的距离bool st[N];int n, m;int prim(){    memset(dist, 0x3f, sizeof dist);        int res = 0;    for (int i = 0; i &lt; n; i ++ )    {        int t = -1;        for (int j = 1; j &lt;= n; j ++ )        {            if ( !st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))                t = j;        }                if (i &amp;&amp; dist[t] == INF) return INF;        if (i) res += dist[t];        st[t] = true;                for (int j = 1; j &lt;= n; j ++) dist[j] = min(dist[j], g[t][j]);    }        return res;    }int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    memset(g, 0x3f, sizeof g);        for (int i = 0; i &lt; m ;i ++){        int a, b, c;        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;c);        g[a][b] = g[b][a] = min(g[a][b], c);    }        int t = prim();    if (t == INF) puts(\"impossible\");    else printf(\"%d\", t);        return 0;}\nKruskal\nAcWing 859. Kruskal算法求最小生成树\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010, M = 2 * 100010, INF = 0x3f3f3f3f;struct Edge{    int a, b, w;    bool operator &lt;(const Edge &amp;W) const    {        return w &lt; W.w;    }}edges[M];int p[N];int n, m;int find(int x){    if (x != p[x]) p[x] = find(p[x]);    return p[x];}int kruskal(){    sort(edges, edges + m);        for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // for (int i = 0; i &lt; m; i ++ ) cout &lt;&lt; edges[i].a &lt;&lt; ' ' &lt;&lt; edges[i].b &lt;&lt; ' ' &lt;&lt; edges[i].w &lt;&lt; endl;        int res = 0, cnt = 0;    for (int i = 0; i &lt; m; i ++ )    {        // cout &lt;&lt; i &lt;&lt; endl;        int a = edges[i].a, b = edges[i].b, w = edges[i].w;                a = find(a), b = find(b);        if (a != b)        {            p[a] = b;            res += w;            cnt ++;        }    }    if (cnt &lt; n - 1) return INF;    return res; }int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; m; i ++ )    {        int a, b, w;        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w);        edges[i] = {a, b, w};    }        int t = kruskal();    if (t == INF) puts(\"impossible\");    else printf(\"%d\", t);            return 0;}\n染色法判定二分图\nAcWing 860. 染色法判定二分图\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 100010, M = 200010;int h[N], e[M], ne[M], idx;int color[N];int n, m;void add(int a, int b)  // 添加一条边a-&gt;b{    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;}bool dfs(int u, int c){    color[u] = c;    for (int i = h[u]; i != -1; i = ne[i]){        int j = e[i];        if (!color[j])        {            if(!dfs(j, 3 - c)) return false;        }        else if (color[j] == c) return false;    }    return true;}int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    memset(h, -1, sizeof h);    while (m -- )    {        int a, b;        scanf(\"%d%d\", &amp;a, &amp;b);        add(a, b), add(b, a);    }        bool flag = true;    for (int i = 1; i &lt;= n; i ++ ){        if (!color[i])         {            if (!dfs(i, 1))            {                flag = false;                break;            }        }    }    if (flag) puts(\"Yes\");    else puts(\"No\");            return 0;}\n匈牙利算法\nAcWing 861. 二分图的最大匹配\n\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100010, M = 2 * 100010, INF = 0x3f3f3f3f;struct Edge{    int a, b, w;    bool operator &lt;(const Edge &amp;W) const    {        return w &lt; W.w;    }}edges[M];int p[N];int n, m;int find(int x){    if (x != p[x]) p[x] = find(p[x]);    return p[x];}int kruskal(){    sort(edges, edges + m);        for (int i = 1; i &lt;= n; i ++ ) p[i] = i;    // for (int i = 0; i &lt; m; i ++ ) cout &lt;&lt; edges[i].a &lt;&lt; ' ' &lt;&lt; edges[i].b &lt;&lt; ' ' &lt;&lt; edges[i].w &lt;&lt; endl;        int res = 0, cnt = 0;    for (int i = 0; i &lt; m; i ++ )    {        // cout &lt;&lt; i &lt;&lt; endl;        int a = edges[i].a, b = edges[i].b, w = edges[i].w;                a = find(a), b = find(b);        if (a != b)        {            p[a] = b;            res += w;            cnt ++;        }    }    if (cnt &lt; n - 1) return INF;    return res; }int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; m; i ++ )    {        int a, b, w;        scanf(\"%d%d%d\", &amp;a, &amp;b, &amp;w);        edges[i] = {a, b, w};    }        int t = kruskal();    if (t == INF) puts(\"impossible\");    else printf(\"%d\", t);            return 0;}","categories":["算法与数据结构"],"tags":["acwing","算法模板题"]},{"title":"Linux基础","url":"/2021/12/15/ubuntu/Linux%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/","content":"Linux服务器端常用命令和操作\n\n常用文件管理命令(1) ctrl c: 取消命令，并且换行(2) ctrl u: 清空本行命令(3) tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项(4) ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件(5) pwd: 显示当前路径(6) cd XXX: 进入XXX目录下, cd .. 返回上层目录(7) cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt(8) mkdir XXX: 创建目录XXX(9) rm XXX: 删除普通文件;  rm XXX -r: 删除文件夹(10) mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令(11) touch XXX: 创建一个文件(12) cat XXX: 展示文件XXX中的内容(13) 复制文本    windows/Linux下：Ctrl + insert，Mac下：command + c(14) 粘贴文本    windows/Linux下：Shift + insert，Mac下：command + v\n\ntmux功能：    (1) 分屏。    (2) 允许断开Terminal连接后，继续运行进程。结构：    一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。    实例：        tmux:            session 0:                window 0:                    pane 0                    pane 1                    pane 2                    ...                window 1                window 2                ...            session 1            session 2            ...操作：    (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。    (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。    (3) 按下Ctrl + a后手指松开，然后按\"（注意是双引号\"）：将当前pane上下平分成两个pane。    (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。    (5) 鼠标点击可以选pane。    (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。    (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。    (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。    (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。    (10) 按下ctrl + a后手指松开，然后按d：挂起当前session。    (11) tmux a：打开之前挂起的session。    (12) 按下ctrl + a后手指松开，然后按s：选择其它session。        方向键 —— 上：选择上一项 session/window/pane        方向键 —— 下：选择下一项 session/window/pane        方向键 —— 右：展开当前项 session/window        方向键 —— 左：闭合当前项 session/window    (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。    (14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。    (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。    (16) 鼠标滚轮：翻阅当前pane内的内容。    (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）    (18) tmux中复制/粘贴文本的通用方式：        (1) 按下Ctrl + a后松开手指，然后按[        (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板        (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处\n\nvim功能：    (1) 命令行模式下的文本编辑器。    (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。    (3) 使用方式：vim filename        如果已有该文件，则打开它。        如果没有该文件，则打开个一个新的文件，并命名为filename模式：    (1) 一般命令模式        默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。    (2) 编辑模式        在一般命令模式里按下i，会进入编辑模式。        按下ESC会退出编辑模式，返回到一般命令模式。    (3) 命令行模式        在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。        可以查找、替换、保存、退出、配置编辑器等。操作：    (1) i：进入编辑模式    (2) ESC：进入一般命令模式    (3) h 或 左箭头键：光标向左移动一个字符    (4) j 或 向下箭头：光标向下移动一个字符    (5) k 或 向上箭头：光标向上移动一个字符    (6) l 或 向右箭头：光标向右移动一个字符    (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符    (8) 0 或 功能键[Home]：光标移动到本行开头    (9) $ 或 功能键[End]：光标移动到本行末尾    (10) G：光标移动到最后一行    (11) :n 或 nG：n为数字，光标移动到第n行    (12) gg：光标移动到第一行，相当于1G    (13) n&lt;Enter&gt;：n为数字，光标向下移动n行    (14) /word：向光标之下寻找第一个值为word的字符串。    (15) ?word：向光标之上寻找第一个值为word的字符串。    (16) n：重复前一个查找操作    (17) N：反向重复前一个查找操作    (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2    (19) :1,$s/word1/word2/g：将全文的word1替换为word2    (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。    (21) v：选中文本    (22) d：删除选中的文本    (23) dd: 删除当前行    (24) y：复制选中的文本    (25) yy: 复制当前行    (26) p: 将复制的数据在光标的下一行/下一个位置粘贴    (27) u：撤销    (28) Ctrl + r：取消撤销    (29) 大于号 &gt;：将选中的文本整体向右缩进一次    (30) 小于号 &lt;：将选中的文本整体向左缩进一次    (31) :w 保存    (32) :w! 强制保存    (33) :q 退出    (34) :q! 强制退出    (35) :wq 保存并退出    (36) :set paste 设置成粘贴模式，取消代码自动缩进    (37) :set nopaste 取消粘贴模式，开启代码自动缩进    (38) :set nu 显示行号    (39) :set nonu 隐藏行号    (40) gg=G：将全文代码格式化    (41) :noh 关闭查找关键词高亮    (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令异常处理：    每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。    如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：        (1) 找到正在打开该文件的程序，并退出        (2) 直接删掉该swp文件即可\n\nshell 语法概论概论shell是我们通过命令行与操作系统沟通的语言。\nshell脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。AC Terminal中的命令行可以看成是一个“shell脚本在逐行执行”。\nLinux中常见的shell脚本有很多种，常见的有：\n\nBourne Shell(/usr/bin/sh或/bin/sh)\nBourne Again Shell(/bin/bash)\nC Shell(/usr/bin/csh)\nK Shell(/usr/bin/ksh)\nzsh\n…Linux系统中一般默认使用bash，所以接下来讲解bash中的语法。文件开头需要写#! /bin/bash，指明bash为脚本解释器。\n\n学习技巧不要死记硬背，遇到含糊不清的地方，可以在Terminal里实际运行一遍。\n脚本示例新建一个test.sh文件，内容如下：#! /bin/bashecho \"Hello World!\"\n运行方式作为可执行文件acs@9e0ebfcd82d7:~$ chmod +x test.sh  # 使脚本具有可执行权限acs@9e0ebfcd82d7:~$ ./test.sh  # 当前路径下执行Hello World!  # 脚本输出acs@9e0ebfcd82d7:~$ /home/acs/test.sh  # 绝对路径下执行Hello World!  # 脚本输出acs@9e0ebfcd82d7:~$ ~/test.sh  # 家目录路径下执行Hello World!  # 脚本输出用解释器执行acs@9e0ebfcd82d7:~$ bash test.shHello World!  # 脚本输出\n注释单行注释每行中#之后的内容均是注释。# 这是一行注释echo 'Hello World'  #  这也是注释\n多行注释格式：:&lt;&lt;EOF第一行注释第二行注释第三行注释EOF其中EOF可以换成其它任意字符串。例如：:&lt;&lt;abc第一行注释第二行注释第三行注释abc:&lt;&lt;!第一行注释第二行注释第三行注释!\n变量定义变量定义变量，不需要加$符号，例如：name1='yxc'  # 单引号定义字符串name2=\"yxc\"  # 双引号定义字符串name3=yxc    # 也可以不加引号，同样表示字符串\n使用变量使用变量，需要加上$符号，或者${}符号。花括号是可选的，主要为了帮助解释器识别变量边界。name=yxcecho $name  # 输出yxcecho ${name}  # 输出yxcecho ${name}acwing  # 输出yxcacwing\n只读变量使用readonly或者declare可以将变量变为只读。name=yxcreadonly namedeclare -r name  # 两种写法均可name=abc  # 会报错，因为此时name只读\n删除变量unset可以删除变量。name=yxcunset nameecho $name  # 输出空行\n变量类型\n自定义变量（局部变量）子进程不能访问的变量\n环境变量（全局变量）子进程可以访问的变量\n\n自定义变量改成环境变量：acs@9e0ebfcd82d7:~$ name=yxc  # 定义变量acs@9e0ebfcd82d7:~$ export name  # 第一种方法acs@9e0ebfcd82d7:~$ declare -x name  # 第二种方法\n环境变量改为自定义变量：acs@9e0ebfcd82d7:~$ export name=yxc  # 定义环境变量acs@9e0ebfcd82d7:~$ declare +x name  # 改为自定义变量\n字符串字符串可以用单引号，也可以用双引号，也可以不用引号。\n单引号与双引号的区别：\n\n单引号中的内容会原样输出，不会执行、不会取变量；\n双引号中的内容可以执行、可以取变量；name=yxc  # 不用引号echo 'hello, $name \\\"hh\\\"'  # 单引号字符串，输出 hello, $name \\\"hh\\\"echo \"hello, $name \\\"hh\\\"\"  # 双引号字符串，输出 hello, yxc \"hh\"\n获取字符串长度name=\"yxc\"echo ${#name}  # 输出3\n提取子串name=\"hello, yxc\"echo ${name:0:5}  # 提取从0开始的5个字符\n默认变量\n\n文件参数变量在执行shell脚本时，可以向脚本传递参数。$1是第一个参数，$2是第二个参数，以此类推。特殊的，$0是文件名（包含路径）。例如：\n创建文件test.sh：#! /bin/bashecho \"文件名：\"$0echo \"第一个参数：\"$1echo \"第二个参数：\"$2echo \"第三个参数：\"$3echo \"第四个参数：\"$4然后执行该脚本：acs@9e0ebfcd82d7:~$ chmod +x test.sh acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4文件名：./test.sh第一个参数：1第二个参数：2第三个参数：3第四个参数：4\n其它参数相关变量\n\n\n\n参数\n说明\n\n\n\n\n$#\n代表文件传入的参数个数，如上例中值为4\n\n\n$*\n由所有参数构成的用空格隔开的字符串，如上例中值为\"$1 $2 $3 $4\"\n\n\n$@\n每个参数分别用双引号括起来的字符串，如上例中值为\"$1\" \"$2\" \"$3\" \"$4\"\n\n\n\n脚本当前运行的进程ID\n\n\n$?\n上一条命令的退出状态（注意不是stdout，而是exit code）。0表示正常退出，其他值表示错误\n\n\n$(command)\n返回command这条命令的stdout（可嵌套）\n\n\n`command`\n返回command这条命令的stdout（不可嵌套）\n\n\n\n\n数组数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。数组下标从0开始。\n定义数组用小括号表示，元素之间用空格隔开。例如：array=(1 abc \"def\" yxc)也可以直接定义数组中某个元素的值：array[0]=1array[1]=abcarray[2]=\"def\"array[3]=yxc\n读取数组中某个元素的值格式：${array[index]}例如：array=(1 abc \"def\" yxc)echo ${array[0]}echo ${array[1]}echo ${array[2]}echo ${array[3]}\n读取整个数组格式：${array[@]}  # 第一种写法${array[*]}  # 第二种写法例如：array=(1 abc \"def\" yxc)echo ${array[@]}  # 第一种写法echo ${array[*]}  # 第二种写法\n数组长度类似于字符串${#array[@]}  # 第一种写法${#array[*]}  # 第二种写法例如：array=(1 abc \"def\" yxc)echo ${#array[@]}  # 第一种写法echo ${#array[*]}  # 第二种写法\nexpr命令expr命令用于求表达式的值，格式为：expr 表达式表达式说明：\n\n用空格隔开每一项\n用反斜杠放在shell特定的字符前面（发现表达式运行错误时，可以试试转义）\n对包含空格和其他特殊字符的字符串要用引号括起来\nexpr会在stdout中输出结果。如果为逻辑关系表达式，则结果为真，stdout为1，否则为0。\nexpr的exit code：如果为逻辑关系表达式，则结果为真，exit code为0，否则为1。\n\n字符串表达式\nlength STRING返回STRING的长度\nindex STRING CHARSETCHARSET中任意单个字符在STRING中最前面的字符位置，下标从1开始。如果在STRING中完全不存在CHARSET中的字符，则返回0。\nsubstr STRING POSITION LENGTH返回STRING字符串中从POSITION开始，长度最大为LENGTH的子串。如果POSITION或LENGTH为负数，0或非数值，则返回空字符串。\n\n示例：str=\"Hello World!\"echo `expr length \"$str\"`  # ``不是单引号，表示执行该命令，输出12echo `expr index \"$str\" aWd`  # 输出7，下标从1开始echo `expr substr \"$str\" 2 3`  # 输出 ell\n整数表达式expr支持普通的算术操作，算术表达式优先级低于字符串表达式，高于逻辑关系表达式。\n\n+ -加减运算。两端参数会转换为整数，如果转换失败则报错。\n\n* / %乘，除，取模运算。两端参数会转换为整数，如果转换失败则报错。\n\n() 可以该表优先级，但需要用反斜杠转义\n\n\n示例：a=3b=4echo `expr $a + $b`  # 输出7echo `expr $a - $b`  # 输出-1echo `expr $a \\* $b`  # 输出12，*需要转义echo `expr $a / $b`  # 输出0，整除echo `expr $a % $b` # 输出3echo `expr \\( $a + 1 \\) \\* \\( $b + 1 \\)`  # 输出20，值为(a + 1) * (b + 1)\n逻辑关系表达式\n|如果第一个参数非空且非0，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非0，否则返回0。如果第一个参数是非空或非0时，不会计算第二个参数。\n\n&amp;如果两个参数都非空且非0，则返回第一个参数，否则返回0。如果第一个参为0或为空，则不会计算第二个参数。\n\n&lt; &lt;= = == != &gt;= &gt;比较两端的参数，如果为true，则返回1，否则返回0。”==”是”=”的同义词。”expr”首先尝试将两端参数转换为整数，并做算术比较，如果转换失败，则按字符集排序规则做字符比较。\n\n() 可以该表优先级，但需要用反斜杠转义\n\n\n示例：a=3b=4echo `expr $a \\&gt; $b`  # 输出0，&gt;需要转义echo `expr $a '&lt;' $b`  # 输出1，也可以将特殊字符用引号引起来echo `expr $a '&gt;=' $b`  # 输出0echo `expr $a \\&lt;\\= $b`  # 输出1c=0d=5echo `expr $c \\&amp; $d`  # 输出0echo `expr $a \\&amp; $b`  # 输出3echo `expr $c \\| $d`  # 输出5echo `expr $a \\| $b`  # 输出3\nread命令read命令用于从标准输入中读取单行数据。当读到文件结束符时，exit code为1，否则为0。\n参数说明\n\n-p: 后面可以接提示信息\n-t：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令\n\n实例：acs@9e0ebfcd82d7:~$ read name  # 读入name的值acwing yxc  # 标准输入acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值acwing yxc  #标准输出acs@9e0ebfcd82d7:~$ read -p \"Please input your name: \" -t 30 name  # 读入name的值，等待时间30秒Please input your name: acwing yxc  # 标准输入acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值acwing yxc  # 标准输出\necho命令echo用于输出字符串。命令格式：echo STRING\n显示普通字符串echo \"Hello AC Terminal\"echo Hello AC Terminal  # 引号可以省略\n显示转义字符echo \"\\\"Hello AC Terminal\\\"\"  # 注意只能使用双引号，如果使用单引号，则不转义echo \\\"Hello AC Terminal\\\"  # 也可以省略双引号\n显示变量name=yxcecho \"My name is $name\"  # 输出 My name is yxc\n显示换行echo -e \"Hi\\n\"  # -e 开启转义echo \"acwing\"\n输出结果：Hiacwing\n显示不换行echo -e \"Hi \\c\" # -e 开启转义 \\c 不换行echo \"acwing\"\n输出结果：Hi acwing\n显示结果定向至文件echo \"Hello World\" &gt; output.txt  # 将内容以覆盖的方式输出到output.txt中\n原样输出字符串，不进行转义或取变量(用单引号)name=acwingecho '$name\\\"'\n输出结果$name\\\"\n显示命令的执行结果echo `date`\n输出结果：Wed Sep 1 11:45:33 CST 2021\nprintf命令printf命令用于格式化输出，类似于C/C++中的printf函数。\n默认不会在字符串末尾添加换行符。\n命令格式：printf format-string [arguments...]\n用法示例脚本内容：printf \"%10d.\\n\" 123  # 占10位，右对齐printf \"%-10.2f.\\n\" 123.123321  # 占10位，保留2位小数，左对齐printf \"My name is %s\\n\" \"yxc\"  # 格式化输出字符串printf \"%d * %d = %d\\n\"  2 3 `expr 2 \\* 3` # 表达式的值作为参数输出结果：       123.123.12    .My name is yxc2 * 3 = 6\ntest命令与判断符号[]逻辑运算符&amp;&amp;和||\n&amp;&amp; 表示与，|| 表示或\n二者具有短路原则：expr1 &amp;&amp; expr2：当expr1为假时，直接忽略expr2expr1 || expr2：当expr1为真时，直接忽略expr2\n表达式的exit code为0，表示真；为非零，表示假。（与C/C++中的定义相反）test命令\n\n在命令行中输入man test，可以查看test命令的用法。\ntest命令用于判断文件类型，以及对变量做比较。\ntest命令用exit code返回结果，而不是使用stdout。0表示真，非0表示假。\n例如：test 2 -lt 3  # 为真，返回值为0echo $?  # 输出上个命令的返回值，输出0acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件homework  output.txt  test.sh  tmpacs@9e0ebfcd82d7:~$ test -e test.sh &amp;&amp; echo \"exist\" || echo \"Not exist\"exist  # test.sh 文件存在acs@9e0ebfcd82d7:~$ test -e test2.sh &amp;&amp; echo \"exist\" || echo \"Not exist\"Not exist  # testh2.sh 文件不存在\n文件类型判断命令格式：test -e filename  # 判断文件是否存在|测试参数    |代表意义||—|—||-e    |文件是否存在||-f    |是否为文件||-d    |是否为目录|\n文件权限判断命令格式：test -r filename  # 判断文件是否可读|测试参数    |代表意义||—|—||-r    |文件是否可读||-w    |文件是否可写||-x    |文件是否可执行||-s    |是否为非空文件|\n整数间的比较命令格式：test $a -eq $b  # a是否等于b|测试参数|    代表意义||—|—||-eq    |a是否等于b||-ne    |a是否不等于b||-gt    |a是否大于b||-lt    |a是否小于b||-ge    |a是否大于等于b||-le    |a是否小于等于b|\n字符串比较\n\n\n\n测试参数\n代表意义\n\n\n\n\ntest -z STRING\n判断STRING是否为空，如果为空，则返回true\n\n\ntest -n STRING\n判断STRING是否非空，如果非空，则返回true（-n可以省略）\n\n\ntest str1 == str2\n判断str1是否等于str2\n\n\ntest str1 != str2\n判断str1是否不等于str2\n\n\n\n\n多重条件判定命令格式：test -r filename -a -x filename|测试参数|    代表意义||—|—||-a    |两条件是否同时成立||-o    |两条件是否至少一个成立||!    |取反。如 test ! -x file，当file不可执行时，返回true|\n判断符号[][]与test用法几乎一模一样，更常用于if语句中。另外[[]]是[]的加强版，支持的特性更多。\n例如：[ 2 -lt 3 ]  # 为真，返回值为0echo $?  # 输出上个命令的返回值，输出0acs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件homework  output.txt  test.sh  tmpacs@9e0ebfcd82d7:~$ [ -e test.sh ] &amp;&amp; echo \"exist\" || echo \"Not exist\"exist  # test.sh 文件存在acs@9e0ebfcd82d7:~$ [ -e test2.sh ] &amp;&amp; echo \"exist\" || echo \"Not exist\"Not exist  # testh2.sh 文件不存在注意：\n\n[]内的每一项都要用空格隔开\n中括号内的变量，最好用双引号括起来\n中括号内的常数，最好用单或双引号括起来例如：name=\"acwing yxc\"[ $name == \"acwing yxc\" ]  # 错误，等价于 [ acwing yxc == \"acwing yxc\" ]，参数太多[ \"$name\" == \"acwing yxc\" ]  # 正确\n判断语句if…then形式\n\n类似于C/C++中的if-else语句。\n单层if命令格式：if conditionthen    语句1    语句2    ...fi示例：a=3b=4if [ \"$a\" -lt \"$b\" ] &amp;&amp; [ \"$a\" -gt 2 ]then    echo ${a}在范围内fi输出结果：3在范围内\n单层if-else命令格式if conditionthen    语句1    语句2    ...else    语句1    语句2    ...fi示例：a=3b=4if ! [ \"$a\" -lt \"$b\" ]then    echo ${a}不小于${b}else    echo ${a}小于${b}fi输出结果：3小于4\n多层if-elif-elif-else命令格式if conditionthen    语句1    语句2    ...elif conditionthen    语句1    语句2    ...elif conditionthen    语句1    语句2else    语句1    语句2    ...fi示例：a=4if [ $a -eq 1 ]then    echo ${a}等于1elif [ $a -eq 2 ]then    echo ${a}等于2elif [ $a -eq 3 ]then    echo ${a}等于3else    echo 其他fi输出结果：其他\ncase…esac形式类似于C/C++中的switch语句。\n命令格式case $变量名称 in    值1)        语句1        语句2        ...        ;;  # 类似于C/C++中的break    值2)        语句1        语句2        ...        ;;    *)  # 类似于C/C++中的default        语句1        语句2        ...        ;;esac示例：a=4case $a in    1)        echo ${a}等于1        ;;      2)        echo ${a}等于2        ;;      3)                                                        echo ${a}等于3        ;;      *)        echo 其他        ;;  esac输出结果：其他\n循环语句for…in…do…done命令格式：for var in val1 val2 val3do    语句1    语句2    ...done示例1，输出a 2 cc，每个元素一行：for i in a 2 ccdo    echo $idone示例2，输出当前路径下的所有文件名，每个文件名一行：for file in `ls`do    echo $filedone示例3，输出1-10for i in $(seq 1 10)do    echo $idone示例4，使用{1..10} 或者 {a..z}for i in {a..z}do    echo $idone\nfor ((…;…;…)) do…done命令格式：for ((expression; condition; expression))do    语句1    语句2done示例，输出1-10，每个数占一行：for ((i=1; i&lt;=10; i++))do    echo $idone\nwhile…do…done循环命令格式：while conditiondo    语句1    语句2    ...done示例，文件结束符为Ctrl+d，输入文件结束符后read指令返回false。while read namedo    echo $namedone\nuntil…do…done循环当条件为真时结束。\n命令格式：until conditiondo    语句1    语句2    ...done示例，当用户输入yes或者YES时结束，否则一直等待读入。until [ \"${word}\" == \"yes\" ] || [ \"${word}\" == \"YES\" ]do    read -p \"Please input yes/YES to stop this program: \" worddone\nbreak命令跳出当前一层循环，注意与C/C++不同的是：break不能跳出case语句。\n示例while read namedo    for ((i=1;i&lt;=10;i++))    do        case $i in            8)                break                ;;            *)                echo $i                ;;        esac    donedone该示例每读入非EOF的字符串，会输出一遍1-7。该程序可以输入Ctrl+d文件结束符来结束，也可以直接用Ctrl+c杀掉该进程。\ncontinue命令跳出当前循环。\n示例：for ((i=1;i&lt;=10;i++))do    if [ `expr $i % 2` -eq 0 ]    then        continue    fi    echo $idone该程序输出1-10中的所有奇数。\n死循环的处理方式如果Terminal可以打开该程序，则输入Ctrl+c即可。\n否则可以直接关闭进程：\n\n使用top命令找到进程的PID\n输入kill -9 PID即可关掉此进程\n\n函数bash中的函数类似于C/C++中的函数，但return的返回值与C/C++不同，返回的是exit code，取值为0-255，0表示正常结束。\n如果想获取函数的输出结果，可以通过echo输出到stdout中，然后通过$(function_name)来获取stdout中的结果。\n函数的return值可以通过$?来获取。\n命令格式：[function] func_name() {  # function关键字可以省略    语句1    语句2    ...}\n不获取 return值和stdout值示例func() {    name=yxc    echo \"Hello $name\"}func输出结果：Hello yxc\n获取 return值和stdout值不写return时，默认return 0。\n示例func() {    name=yxc    echo \"Hello $name\"    return 123}output=$(func)ret=$?echo \"output = $output\"echo \"return = $ret\"输出结果：output = Hello yxcreturn = 123\n函数的输入参数在函数内，$1表示第一个输入参数，$2表示第二个输入参数，依此类推。\n注意：函数内的$0仍然是文件名，而不是函数名。\n示例：func() {  # 递归计算 $1 + ($1 - 1) + ($1 - 2) + ... + 0    word=\"\"    while [ \"${word}\" != 'y' ] &amp;&amp; [ \"${word}\" != 'n' ]    do        read -p \"要进入func($1)函数吗？请输入y/n：\" word    done    if [ \"$word\" == 'n' ]    then        echo 0        return 0    fi      if [ $1 -le 0 ]     then        echo 0        return 0    fi      sum=$(func $(expr $1 - 1))    echo $(expr $sum + $1)}echo $(func 10)输出结果：55\n函数内的局部变量可以在函数内定义局部变量，作用范围仅在当前函数内。\n可以在递归函数中定义局部变量。\n命令格式：local 变量名=变量值例如：#! /bin/bashfunc() {    local name=yxc    echo $name}funcecho $name输出结果：yxc第一行为函数内的name变量，第二行为函数外调用name变量，会发现此时该变量不存在。\nexit命令exit命令用来退出当前shell进程，并返回一个退出状态；使用$?可以接收这个退出状态。\nexit命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。\nexit退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。\n示例：\n创建脚本test.sh，内容如下：#! /bin/bashif [ $# -ne 1 ]  # 如果传入参数个数等于1，则正常退出；否则非正常退出。then    echo \"arguments not valid\"    exit 1else    echo \"arguments valid\"    exit 0fi执行该脚本：acs@9e0ebfcd82d7:~$ chmod +x test.sh acs@9e0ebfcd82d7:~$ ./test.sh acwingarguments validacs@9e0ebfcd82d7:~$ echo $?  # 传入一个参数，则正常退出，exit code为00acs@9e0ebfcd82d7:~$ ./test.sh arguments not validacs@9e0ebfcd82d7:~$ echo $?  # 传入参数个数不是1，则非正常退出，exit code为11\n文件重定向每个进程默认打开3个文件描述符：\n\nstdin标准输入，从命令行读取数据，文件描述符为0\nstdout标准输出，向命令行输出数据，文件描述符为1\nstderr标准错误输出，向命令行输出数据，文件描述符为2可以用文件重定向将这三个文件重定向到其他文件中。\n\n重定向命令列表\n\n\n\n命令\n说明\n\n\n\n\ncommand &gt; file\n将tdout重定向到file中\n\n\ncommand &lt; file\n将stdin重定向到file中\n\n\ncommand &gt;&gt; file\n将stdout以追加方式重定向到file中\n\n\ncommand n&gt; file\n将文件描述符n重定向到file中\n\n\ncommand n&gt;&gt; file\n将文件描述符n以追加方式重定向到file中\n\n\n\n\n输入和输出重定向echo -e \"Hello \\c\" &gt; output.txt  # 将stdout重定向到output.txt中echo \"World\" &gt;&gt; output.txt  # 将字符串追加到output.txt中read str &lt; output.txt  # 从output.txt中读取字符串echo $str  # 输出结果：Hello World\n同时重定向stdin和stdout创建bash脚本：#! /bin/bashread aread becho $(expr \"$a\" + \"$b\")创建input.txt，里面的内容为：34执行命令：acs@9e0ebfcd82d7:~$ chmod +x test.sh  # 添加可执行权限acs@9e0ebfcd82d7:~$ ./test.sh &lt; input.txt &gt; output.txt  # 从input.txt中读取内容，将输出写入output.txt中acs@9e0ebfcd82d7:~$ cat output.txt  # 查看output.txt中的内容7\n引入外部脚本类似于C/C++中的include操作，bash也可以引入其他文件中的代码。\n语法格式：. filename  # 注意点和文件名之间有一个空格或source filename示例\n创建test1.sh，内容为：#! /bin/bashname=yxc  # 定义变量name然后创建test2.sh，内容为：#! /bin/bashsource test1.sh # 或 . test1.shecho My name is: $name  # 可以使用test1.sh中的变量执行命令：acs@9e0ebfcd82d7:~$ chmod +x test2.sh acs@9e0ebfcd82d7:~$ ./test2.sh My name is: yxc\n\nsshssh登录基本用法远程登录服务器：\nssh user@hostname\n\nuser : 用户名\nhostname : IP地址或域名\n\n第一次登录时会提示：\nThe authenticity of host '123.57.47.211 (123.57.47.211)' can't be established.ECDSA key fingerprint is SHA256:iy237yysfCe013/l+kpDGfEG9xxHxm0dnxnAbJTPpG8.Are you sure you want to continue connecting (yes/no/[fingerprint])?\n输入yes，然后回车即可。这样会将该服务器的信息记录在~/.ssh/known_hosts文件中。\n然后输入密码即可登录到远程服务器中。\n默认登录端口号为22。如果想登录某一特定端口：\nssh user@hostname -p 22\n\n配置文件创建文件~/.ssh/config。\n然后在文件中输入：\nHost myserver1    HostName IP地址或域名    User 用户名Host myserver2    HostName IP地址或域名    User 用户名\n之后再使用服务器时，可以直接使用别名myserver1、myserver2。\n\n密钥登录创建密钥：\nssh-keygen\n然后一直回车即可。\n执行结束后，~/.ssh/目录下会多两个文件：\n\nid_rsa：私钥\n\nid_rsa.pub：公钥\n\n\n之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。\n例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的~/.ssh/authorized_keys文件里即可。\n也可以使用如下命令一键添加公钥：\nssh-copy-id myserver\n\n执行命令命令格式：ssh user@hostname command例如：ssh user@hostname ls -a或者# 单引号中的$i可以求值ssh myserver 'for ((i = 0; i &lt; 10; i ++ )) do echo $i; done'或者# 双引号中的$i不可以求值ssh myserver \"for ((i = 0; i &lt; 10; i ++ )) do echo $i; done\"\n\nscp传文件基本用法命令格式：scp source destination将source路径下的文件复制到destination中\n一次复制多个文件：scp source1 source2 destination复制文件夹：scp -r ~/tmp myserver:/home/acs/将本地家目录中的tmp文件夹复制到myserver服务器中的/home/acs/目录下。scp -r ~/tmp myserver:homework/将本地家目录中的tmp文件夹复制到myserver服务器中的~/homework/目录下。scp -r myserver:homework .将myserver服务器中的~/homework/文件夹复制到本地的当前路径下。\n指定服务器的端口号：scp -P 22 source1 source2 destination注意： scp的-r -P等参数尽量加在source和destination之前。\n使用scp配置其他服务器的vim和tmuxscp ~/.vimrc ~/.tmux.conf myserver:\n\ngitgit基本概念\n工作区：仓库的目录。工作区是独立于各个分支的。\n暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。\n版本库：存放所有已经提交到本地仓库的代码版本\n版本结构：树结构，树中每个节点代表一个代码版本。\n\ngit常用命令\ngit config --global user.name xxx：设置全局用户名，信息记录在~/.gitconfig文件中\ngit config --global user.email xxx@xxx.com：设置全局邮箱地址，信息记录在~/.gitconfig文件中\ngit init：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中\ngit add XX：将XX文件添加到暂存区\ngit add .：将所有待加入暂存区的文件加入暂存区\n\n\ngit rm --cached XX：将文件从仓库索引目录中删掉\ngit commit -m \"给自己看的备注信息\"：将暂存区的内容提交到当前分支\ngit status：查看仓库状态\ngit diff XX：查看XX文件相对于暂存区修改了哪些内容\ngit log：查看当前分支的所有版本\ngit reflog：查看HEAD指针的移动历史（包括被回滚的版本）\ngit reset --hard HEAD^ 或 git reset --hard HEAD~：将代码库回滚到上一个版本\ngit reset --hard HEAD^^：往上回滚两次，以此类推\ngit reset --hard HEAD~100：往上回滚100个版本\ngit reset --hard 版本号：回滚到某一特定版本\n\n\ngit checkout — XX或git restore XX：将XX文件尚未加入暂存区的修改全部撤销\ngit remote add origin git@git.acwing.com:xxx/XXX.git：将本地仓库关联到远程仓库\ngit push -u (第一次需要-u以后不需要)：将当前分支推送到远程仓库\ngit push origin branch_name：将本地的某个分支推送到远程仓库\n\n\ngit clone git@git.acwing.com:xxx/XXX.git：将远程仓库XXX下载到当前目录下\ngit checkout -b branch_name：创建并切换到branch_name这个分支\ngit branch：查看所有分支和当前所处分支\ngit checkout branch_name：切换到branch_name这个分支\ngit merge branch_name：将分支branch_name合并到当前分支上\ngit branch -d branch_name：删除本地仓库的branch_name分支\ngit branch branch_name：创建新分支\ngit push --set-upstream origin branch_name：设置本地的branch_name分支对应远程仓库的branch_name分支\ngit push -d origin branch_name：删除远程仓库的branch_name分支\ngit pull：将远程仓库的当前分支与本地仓库的当前分支合并\ngit pull origin branch_name：将远程仓库的branch_name分支与本地仓库的当前分支合并\n\n\ngit branch --set-upstream-to=origin/branch_name1 branch_name2：将远程的branch_name1分支与本地的branch_name2分支对应\ngit checkout -t origin/branch_name: 将远程的branch_name分支拉取到本地\ngit stash：将工作区和暂存区中尚未提交的修改存入栈中\ngit stash apply：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素\ngit stash drop：删除栈顶存储的修改\ngit stash pop：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素\ngit stash list：查看栈中所有元素\n\n\n管道、环境变量与常用命令管道概念管道类似于文件重定向，可以将前一个命令的stdout重定向到下一个命令的stdin。\n要点\n管道命令仅处理stdout，会忽略stderr。\n管道右边的命令必须能接受stdin。\n多个管道命令可以串联。\n\n与文件重定向的区别\n文件重定向左边为命令，右边为文件。\n管道左右两边均为命令，左边有stdout，右边有stdin。举例统计当前目录下所有python文件的总行数，其中find、xargs、wc等命令可以参考常用命令这一节内容。find . -name '*.py' | xargs cat | wc -l\n\n\n\n环境变量概念Linux系统中会用很多环境变量来记录配置信息。环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。\n查看列出当前环境下的所有环境变量：env  # 显示当前用户的变量set  # 显示当前shell的变量，包括当前用户的变量;export  # 显示当前导出成用户变量的shell变量输出某个环境变量的值：echo $PATH\n修改环境变量的定义、修改、删除操作可以参考shell语法——变量这一节的内容。\n为了将对环境变量的修改应用到未来所有环境下，可以将修改命令放到~/.bashrc文件中。修改完~/.bashrc文件后，记得执行source ~/.bashrc，来将修改应用到当前的bash环境下。\n为何将修改命令放到~/.bashrc，就可以确保修改会影响未来所有的环境呢？\n\n每次启动bash，都会先执行~/.bashrc。\n每次ssh登陆远程服务器，都会启动一个bash命令行给我们。\n每次tmux新开一个pane，都会启动一个bash命令行给我们。\n所以未来所有新开的环境都会加载我们修改的内容。常见环境变量\n\n\nHOME：用户的家目录。\nPATH：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。\nLD_LIBRARY_PATH：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。\nC_INCLUDE_PATH：C语言的头文件路径，内容是以冒号分隔的路径列表。\nCPLUS_INCLUDE_PATH：CPP的头文件路径，内容是以冒号分隔的路径列表。\nPYTHONPATH：Python导入包的路径，内容是以冒号分隔的路径列表。\nJAVA_HOME：jdk的安装目录。\nCLASSPATH：存放Java导入类的路径，内容是以冒号分隔的路径列表。\n\n常用命令Linux命令非常多，本节讲解几个常用命令。其他命令依赖于大家根据实际操作环境，边用边查。\n系统状况\ntop：查看所有进程的信息（Linux的任务管理器）\n\n\n打开后，输入M：按使用内存排序\n打开后，输入P：按使用CPU排序\n打开后，输入q：退出\n\n\ndf -h：查看硬盘使用情况\nfree -h：查看内存使用情况\ndu -sh：查看当前目录占用的硬盘空间\nps aux：查看所有进程\nkill -9 pid：杀死编号为pid的进程\n\n\n传递某个具体的信号：kill -s SIGTERM pid\n\n\nnetstat -nt：查看所有网络连接\nw：列出当前登陆的用户\nping www.baidu.com：检查是否连网\n\n文件权限\nchmod：修改文件权限\n\n\nchmod +x xxx：给xxx添加可执行权限\nchmod -x xxx：去掉xxx的可执行权限\nchmod 777 xxx：将xxx的权限改成777\nchmod 777 xxx -R：递归修改整个文件夹的权限\n\n文件检索\nfind /path/to/directory/ -name '*.py'：搜索某个文件路径下的所有*.py文件\ngrep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行。\nwc：统计行数、单词数、字节数\n\n\n既可以从stdin中直接读入内容；也可以在命令行参数中传入文件名列表；\nwc -l：统计行数\nwc -w：统计单词数\nwc -c：统计字节数\n\n\ntree：展示当前目录的文件结构\n\n\ntree /path/to/directory/：展示某个目录的文件结构\ntree -a：展示隐藏文件\n\n\nag xxx：搜索当前目录下的所有文件，检索xxx字符串\ncut：分割一行内容\n\n\n从stdin中读入多行数据\necho $PATH | cut -d ':' -f 3,5：输出PATH用:分割后第3、5列数据\necho $PATH | cut -d ':' -f 3-5：输出PATH用:分割后第3-5列数据\necho $PATH | cut -c 3,5：输出PATH的第3、5个字符\necho $PATH | cut -c 3-5：输出PATH的第3-5个字符\n\n\nsort：将每行内容按字典序排序\n\n\n可以从stdin中读取多行数据\n可以从命令行参数中读取文件名列表\n\n\nxargs：将stdin中的数据用空格或回车分割成命令行参数\n\n\nfind . -name '*.py' | xargs cat | wc -l：统计当前目录下所有python文件的总行数查看文件内容\n\n\nmore：浏览文件内容\n\n\n回车：下一行\n空格：下一页\nb：上一页\nq：退出\n\n\nless：与more类似，功能更全\n\n\n回车：下一行\ny：上一行\nPage Down：下一页\nPage Up：上一页\nq：退出\n\n\nhead -3 xxx：展示xxx的前3行内容\n\n\n同时支持从stdin读入内容\n\n\ntail -3 xxx：展示xxx末尾3行内容\n\n\n同时支持从stdin读入内容\n\n用户相关\nhistory：展示当前用户的历史操作。内容存放在~/.bash_history中\n\n工具\nmd5sum：计算md5哈希值\n\n可以从stdin读入内容\n也可以在命令行参数中传入文件名列表；\n\n\ntime command：统计command命令的执行时间\nipython3：交互式python3环境。可以当做计算器，或者批量管理文件。\n! echo \"Hello World\"：!表示执行shell脚本\n\n\nwatch -n 0.1 command：每0.1秒执行一次command命令\ntar：压缩文件\n\ntar -zcvf xxx.tar.gz /path/to/file/*：压缩\ntar -zxvf xxx.tar.gz：解压缩\n\n\ndiff xxx yyy：查找文件xxx与yyy的不同点\n\n安装软件\nsudo command：以root身份执行command命令\napt-get install xxx：安装软件\npip install xxx --user --upgrade：安装python包\n\n\n租云服务器及配置docker环境概述云平台的作用:存放我们的docker容器，让计算跑在云端。获得公网IP地址，让每个人可以访问到我们的服务。\n任选一个云平台即可，推荐配置：1核 2GB（后期可以动态扩容，前期配置低一些没关系）网络带宽采用按量付费，最大带宽拉满即可（费用取决于用量，与最大带宽无关）系统版本：ubuntu 20.04 LTS（推荐用统一版本，避免后期出现配置不兼容的问题）\n租云平台阿里云阿里云地址：https://www.aliyun.com/\n创建工作用户username(username改成你自己的)并赋予sudo权限登录到新服务器。打开Terminal，然后：ssh root@xxx.xxx.xxx.xxx  # xxx.xxx.xxx.xxx替换成新服务器的公网IP创建username用户：adduser username  # 创建用户acsusermod -aG sudo acs  # 给用户acs分配sudo权限\n配置免密登录方式退回Terminal，然后配置username用户的别名和免密登录，可以参考ssh——ssh登录。\n配置新服务器的工作环境将Terminal的配置传到新服务器上：scp .bashrc .vimrc .tmux.conf server_name:  # server_name需要换成自己配置的别名\n安装tmux和docker登录自己的服务器，然后安装tmux：sudo apt-get updatesudo apt-get install tmux打开tmux。（养成好习惯，所有工作都在tmux里进行，防止意外关闭终端后，工作进度丢失）\n然后在tmux中根据docker安装教程安装docker即可。\n腾讯云腾讯云地址：https://cloud.tencent.com/\n华为云华为云地址：https://www.huaweicloud.com/\ndocker教程将当前用户添加到docker用户组为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组(可以参考官方文档)：sudo usermod -aG docker $USER\n镜像（images）\ndocker pull ubuntu:20.04：拉取一个镜像\n\ndocker images：列出本地所有镜像\n\ndocker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04：删除镜像ubuntu:20.04\ndocker [container] commit CONTAINER IMAGE_NAME:TAG：创建某个container的镜像\ndocker save -o ubuntu_20_04.tar ubuntu:20.04：将镜像ubuntu:20.04导出到本地文件ubuntu_20_04.tar中\ndocker load -i ubuntu_20_04.tar：将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来\n\n容器(container)\ndocker [container] create -it ubuntu:20.04：利用镜像ubuntu:20.04创建一个容器。\n\ndocker ps -a：查看本地的所有容器\n\ndocker [container] start CONTAINER：启动容器\ndocker [container] stop CONTAINER：停止容器\ndocker [container] restart CONTAINER：重启容器\ndocker [contaienr] run -itd ubuntu:20.04：创建并启动一个容器\ndocker [container] attach CONTAINER：进入容器\n先按Ctrl-p，再按Ctrl-q可以挂起容器\n\n\ndocker [container] exec CONTAINER COMMAND：在容器中执行命令\ndocker [container] rm CONTAINER：删除容器\ndocker container prune：删除所有已停止的容器\ndocker export -o xxx.tar CONTAINER：将容器CONTAINER导出到本地文件xxx.tar中\ndocker import xxx.tar image_name:tag：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag\ndocker export/import与docker save/load的区别：\n\nexport/import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态\n\nsave/load会保存完整记录，体积更大\n\n\n\ndocker top CONTAINER：查看某个容器内的所有进程\n\ndocker stats：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息\ndocker cp xxx CONTAINER:xxx 或 docker cp CONTAINER:xxx xxx：在本地和容器间复制文件\ndocker rename CONTAINER1 CONTAINER2：重命名容器\ndocker update CONTAINER --memory 500MB：修改容器限制\n\n实战进入AC Terminal，然后：scp /var/lib/acwing/docker/images/docker_lesson_1_0.tar server_name:  # 将镜像上传到自己租的云端服务器ssh server_name  # 登录自己的云端服务器docker load -i docker_lesson_1_0.tar  # 将镜像加载到本地docker run -p 20000:22 --name my_docker_server -itd docker_lesson:1.0  # 创建并运行docker_lesson:1.0镜像docker attach my_docker_server  # 进入创建的docker容器passwd  # 设置root密码去云平台控制台中修改安全组配置，放行端口20000。\n返回AC Terminal，即可通过ssh登录自己的docker容器：ssh root@xxx.xxx.xxx.xxx -p 20000  # 将xxx.xxx.xxx.xxx替换成自己租的服务器的IP地址然后，可以仿照上节课内容，创建工作账户acs。\n最后，可以参考ssh——ssh登录配置docker容器的别名和免密登录。\n小Tips如果apt-get下载软件速度较慢，可以参考清华大学开源软件镜像站中的内容，修改软件源。\n","categories":["教程"],"tags":["Linux"]}]